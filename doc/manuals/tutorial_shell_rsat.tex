%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Tutorials for theset pa command-line utilization of
% the Regulatory Sequence Analysis Tools
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{article}
%\documentstyle[makeidx]{book}
\makeindex
\include{rsat_latex_commands}

\begin{document}

\title{Regulatory Sequence Analysis Tools \\
Tutorial \\
Command-line utilization of the tools}

\author{
	Jacques van Helden \\
	\email{jvanheld@ucmb.ulb.ac.be} \\
	\scmb 
}

\maketitle

\newpage
\tableofcontents
\newpage

\section{Warning}

This tutorial is under construction. Some sections are still to be
written, and are only mentioned as a title without any following
text. The tutorial will be progressively completed. We provided it as
it is, because it can already provide a good starter for the analysis
of regulatory sequences.

\section{Introduction}

This tutorial aims at introducing how to use Regulatory Sequence
Analysis Tools (\RSAT) directly from the unix shell.

\RSAT is a package combining a series of specialized programs for the
detection of regulatory signals in non-coding sequences. A variety of
tasks can be performed: retrieval of upstream or downstream sequences,
pattern discovery, pattern matching, gaphical representation of
regulatory regions, sequence conversions, \ldots.

A web interface has been developed for the most common tools, and is
freely available for academic users.

\url{http://www.ucmb.ulb.ac.be/bioinformatics/rsa-tools/}

All programs can also be used directly from the unix shell. The shell
access is less intuitive than the web interface, but is very
convenient for automatizing repetitive tasks.

This tutorial was written by Jacques van Helden
(\email{jvanheld@ucmb.ulb.ac.be}).  Unless otherwise specified, the
programs presented here were written by Jacques van Helden.

\section{Accessing the programs}

In order to use the shell version of \RSAT, you first need an account
on a unix machine where \RSAT is installed, and you should know the
directory where \RSAT have been installed. (if you don't know, ask
assistance to your system administrator).

For this tutorial, let us assume that \RSAT is installed in the
directory \texttt{/usr/local/rsa-tools}

\begin{enumerate}

\item Open a telnet or ssh session to your account.

\item If your default shell is \textbf{tcsh}, type the following
commands.

\begin{verbatim}
set RSAT=/usr/local/rsa-tools
set path=($path $RSAT/perl-scripts)
set PATH=($path $RSAT/bin/)
rehash
\end{verbatim}

If you are using a different shell (e.g. bash), you might need a
slightly different command to obtain the same result. See you system
manager in case of doubt.

\item The previous step should have included all the \RSAT programs in
your path.  To check if it worked, just type:

\begin{verbatim}
random-seq -l 350
\end{verbatim}

If your configuration is correct, this command should return a random
sequence of 350 nucleotides.

\end{enumerate}

You are now able to use any program from the \RSAT package, untill you
quit your telnet session. It is however not very convenient to set the
path manually each time you open a new connection. You can modify your
defaul configuration by including the above commands in the file
\texttt{.personal-cshrc} in the root of your home directory. If you
don't know how to modify this file, see the system adiministrator.

\section{Getting help} 

The first step before using any program is to read the manual. All
programs in the \RSAT package come with an on-line help, which
is obtained by typing the name of the program followed by
\texttt{-h}. For example, to get a detailed description of the
functionality and options for the program \texttt{retrieve-seq}, type

\begin{verbatim}
retrieve-seq -h
\end{verbatim}

The detailed help is specially convenient before using the program for
the first time. A complementary functionality is offered by the option
\texttt{-help}, which prints a short list of options. Try:

\begin{verbatim}
retrieve-seq -help
\end{verbatim}

which is convenient to remind the precise formulation of arguments for
a given progam.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Sequence retrieval
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Retrieving sequences}

The program \texttt{retrieve-seq} allows you to retrieve sequences
from a genome (provided this genome is supported on your machine). In
particular (and by default), this program extracts the non-coding
sequences located upstream the start codon of a series of genes, where
regulatory elements are generally found, at least in microbial
organisms.

\subsubsection{Retrieving a single upstream sequence}
First trial: we will extract the upstream sequence for a single yeast
gene. Try:

\begin{verbatim}
retrieve-seq -type upstream -org Escherichia_coli_K12 \
    -q metA -from -200 -to -1
\end{verbatim}

This command retrieves a 200 bp upstream sequence for the gene metA of
\textit{Escherichia coli}. Note the negative coordinates, indicating the
upstream side. Also note that all coordinates are calculated starting
relative to the star codon (position 0 is the A from the start ATG).

\subsubsection{Combining upstream and coding sequence}
For coli genes, regulatory signals sometimes overlap the 5' side of
the coding sequence. By doing so, they exert a repression effect by
preventing RNA-polymerase from binding DNA. \texttt{retrieve-seq}
allows you to extract a sequence that combines an upstream and a
coding segment. Try:

\begin{verbatim}
retrieve-seq -type upstream -org Escherichia_coli_K12 \
    -q metA -from -200 -to 49
\end{verbatim}

\subsubsection{Retrieving a few upstream sequences}

The option \texttt{-q} can be used iteratively in a command to
retrieve sequences for several genes.

\begin{verbatim}
retrieve-seq -org Escherichia_coli_K12 \
    -from -200 -to 49 -q metA -q metB -q metC
\end{verbatim}

\subsubsection{Retrieving many upstream sequences}

If you have to retrieve a large number of sequences, it might become
cumbersome to type each gene name on the command-line. A list of gene
enames can be provided in a text file, each gene name coming as the
first word of a new line.

To create a test file, you can execute the following steps:
\begin{enumerate}
\item to create a new file, call the standard unix command 

\begin{verbatim}
cat > PHO_genes.txt
\end{verbatim} 

\item You can now type a list of gene names, for example:

\begin{verbatim}
PHO5
PHO8
PHO11
PHO81
PHO84
\end{verbatim} 

\item Once you have finished typing gene names, press \texttt{Ctrl-D}

\item Check the content of your file by typing 

\begin{verbatim}
cat PHO_genes.txt
\end{verbatim} 

\end{enumerate}


This file can now be used as input to indicate the list of genes.

\begin{verbatim}
retrieve-seq -type upstream -i PHO_genes.txt \
    -org Saccharomyces_cerevisie \
    -from -800 -to -1 -label orf
\end{verbatim} 

The option \texttt{-o} allows you to indicate a file where the
sequence will be stored.

\begin{verbatim}
retrieve-seq -type upstream -i PHO_genes.txt \
    -org Saccharomyces_cerevisie \
    -from -800 -to -1 -label gene \
    -o PHO_up800.fasta
\end{verbatim} 

Check the sequence file:

\begin{verbatim}
more PHO_up800.fasta
\end{verbatim}

\subsubsection{Retrieving all upstream sequences}

For genome-scale analyses, it is convenient to retrieve upstream
sequences for all the genes of a given genome, without having to
specify the complete list of names. For this, simply use the option
\texttt{-all}.

As an illustration, we will use \command{retrieve-seq} to retrieve all
the start codons from \organism{Escherichia coli}. As we saw before,
negative coordinates specify upstream positions, 0 being the first
base of the coding sequence. Thus, by specifying positions 0 to 2, we
will extract the three first coding bases, i.e. the start codon. 

\begin{verbatim}
retrieve-seq -type upstream -org Escherichia_coli_K12 \
    -from 0 -to 2 \
    -all -format wc -nocomments -label orf_gene \
    -o Escherichia_coli_K12_start_codons.wc
\end{verbatim}

Check the result:

\begin{verbatim}
more Escherichia_coli_K12_start_codons.wc
\end{verbatim}

\subsubsection{Retrieving downstream sequences}

\texttt{retrieve-seq} can also be used to retrieve downstream
sequences. in this case, the origin (position 0) is the third base of
the stop codon, positive coordinates indicate downstream (3')
location, and negative coordinates locations upstream (5') from th
stop codon (i.e. coding sequences). 

For example, the following command returns all the stop codons for
\organism{Escherichia coli}.

\begin{verbatim}
retrieve-seq -type upstream -org Escherichia_coli_K12 \
    -from -2 -to 0 \
    -all -format wc -nocomments -label orf_gene \
    -o Escherichia_coli_K12_stop_codons.wc
\end{verbatim}

\subsubsection{Retrieving random sequences}

\texttt{retrieve-seq} can also be used to retrieve random sequences,
with two flavours :

\begin{itemize}
\item retrieving upstream, downstream or ORF sequence for a random
selection of ORFs
\item retrieving random genomic fragments
\end{itemize}

In both cases, the number of sequences to retrieve is specified with
the option \option{-random}, followed by a natural number.

The type of sequence is specified with the option \option{-type}, as
usual. Random genomic segments can be obtained by specifying
``random'' as sequence type.

For example, To retrieve upstream sequences for a random selection of
100 yeast ORFs :
\begin{verbatim}
retrieve-seq -org Saccharomyces_cerevisiae \
    -randsel 100 -type upstream
\end{verbatim}

Another example: to retrieve 100 random genomic segments of size 200
in \organism{Saccharomyces cerevisiae} :
\begin{verbatim}
retrieve-seq  -org Saccharomyces_cerevisiae \
    -randsel 100 -type random
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% PATTERN DISCOVERY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pattern discovery}

In a pattern discovery problem, you start from a set of
functionally related sequences (e.g.  upstream sequences for a set of
co-regulated genes) and you try to extract motifs (e.g. regulatory
elements) that are characteristic of these sequences.

Several approaches exist, either string-based or matrix-based. For
yeast regulatory elements, string-based approaches give excellent
results. The advantages:

\begin{itemize}
\item Simple to use
\item Deterministic (if you run it repeatedly, you always get the same result)
\item Easily parametrizable
\item Easy to interpret
\item Fast
\item Able to return a negative answer: if no motif is significant,
the programs return an empty list of motifs. This is particularly
important to reduce the rate of false positive.
\end{itemize}

Matrix-based approach can provide a more refined description of omtifs
presenting a high degree of degeneracy. The problem of matrix-based
approaches is that it is impossible to analyze all possible
position-weight matrices, and thus on has to use heuristics. There is
thus a risk to miss the global optimum because the program is
attracted to local maxima. Another problem is that there are more
parameters to select (typically, matrix width and expected number of
occurrences of the motif), and their choice drastically affects the
quality of the result. Last problem: the result is not easily
interpretable because the programs always return an answer.

Basically, I would tend to prefer string-based approaches for any
problem of pattern discovery. On the contrary, matrix-based approaches
are much more sensitive for pattern matching problems (see below). The
ideal would thus be to combine string-based pattern disovery and
matrix-based pattern matching.

\subsection{Requirements}
This part of the tutorial assumes that you already performed the
tutorial about sequence retrieval (above), and that you have the
result files in the current directory. Check with the command:

\begin{verbatim}
ls -1
\end{verbatim}

You should see the following file list:
\begin{verbatim}
PHO_genes.txt
PHO_up800.fasta
Escherichia_coli_K12_start_codons.wc
Escherichia_coli_K12_stop_codons.wc
\end{verbatim}

\subsection{oligo-analysis}

The program \texttt{oligo-analysis} is the simplest pattern discovery
program. It counts the number of occurrences of all oligonucleotides
(word) of a given length (typically 6), and compares, for each word,
the observed and expected occurrences, and return words with a
significant level of over-representation.  

Despite its simplicity, this program already returns good results for
may families of co-regulated genes in yeast.

In a first time, we will simply use the program to count word
occurrences. The application will be to check the start and stop
codons retrieved above. 

We will then use \texttt{oligo-analysis} in a pattern discovery
process, to detect over-represented words from the set of 5 upstream
sequences retrieved above (the PHO family).  In a first time, we will
use the appropriate parameters, which have been optimized for pattern
discovery in yeast upstream sequences (van Helden et al., 1998). We
will then use the sub-optimal settings to illustrate the fact that the
success of word-based pattern-discovery crucially depends on a
rigorous statistical approach.

\subsubsection{Counting word occurrences and frequencies}

Try the following command:

\begin{verbatim}
oligo-analysis -i Escherichia_coli_K12_start_codons.wc \
    -format wc -l 3 -1str
\end{verbatim}

Call the on-line option description to understand the meaning of the options you used:
\begin{verbatim}
oligo-analysis -help
\end{verbatim}

Or, to obtain more details:
\begin{verbatim}
oligo-analysis -h
\end{verbatim}


You can also ask some more information (verbose) and store the result
in a file:

\begin{verbatim}
oligo-analysis -i Escherichia_coli_K12_start_codons.wc \
    -format wc -l 3 -1str \
    -return occ,freq -v \
    -o Escherichia_coli_K12_start_codon_frequencies
\end{verbatim}

Reaad the result file:

\begin{verbatim}
more Escherichia_coli_K12_start_codon_frequencies
\end{verbatim}

Note the effect of the verbose. You receive information about sequence
length, number of possible oligonucleotides, the content of the output
columns, ...

\textbf{Exercise:} check the frequencies of \textit{E.coli} stop codons.

\subsubsection{Pattern discovery in yeast upstream regions}

Try the following command:

\begin{verbatim} 
oligo-analysis -i PHO_up800.fasta -format fasta \
    -v -l 6 -2str \
    -return occ,proba -thosig 0 -ncf \
    -org Saccharomyces_cerevisie -sort -o \
    PHO_up800_6nt_2str_ncf_sig0 
\end{verbatim}

Call the on-line help to understand the meaning of the parameters.

\begin{verbatim} 
oligo-analysis -h
\end{verbatim}

Note that we used pre-calibrated tables as estimators of expected word
frequencies. these tables have been previously calculated (with
oligo-analysis) by counting hexanucleotide frequencies in the whole
set of yeast non-coding (intergenic) regions. Our experience is that
these frequencies are the optimal estimator for discovering regulatory
elements in non-coding sequences. 

Look the result file:

\begin{verbatim}
more PHO_up800_6nt_2str_ncf_sig0
\end{verbatim}

A few questions:
\begin{enumerate}
\item How many hexanucleotides can be formed with the 4-letter alphabet A,T,G,C ?
\item How may possible oligonucleotides are indicated ? Is it the number you would expect ? Why ?
\item How many patterns have been selected as significant ?
\item Do you see some similarity between some of the selected patterns ?
\end{enumerate}

\subsubsection{Answers}

\begin{enumerate}
\item $4^6=4,096$
\item $2,080$. This is due to the fact that the analysis was performed on
both strands. Each oligonucleotide is thus equivalent to its reverse
complement.
\item $9$
\item there are strong mutual overlap between some words (e.g. \texttt{cACGTG}
and \texttt{ACGTGc}).
\end{enumerate}

\subsubsection{Assembling the patterns}

A separate program, \texttt{pattern-assembly} allows to assemble a
list of patterns, in order to group those that overlap mutually. Try:

\begin{verbatim}
pattern-assembly -i PHO_up800_6nt_2str_ncf_sig0 \
    -v -sc 7 -subst 1 \
    -2str -o PHO_up800_6nt_2str_ncf_sig0.assemb
\end{verbatim}


Call the on-line help to have a look at the assembly parameters. 
\begin{verbatim}
pattern-assembly -h
\end{verbatim}

Look at the result. There are two alignments (with two contigs), and
two isolated patterns. Each alignment is made of strongly overlapping
patterns. The first alignment (cgcacgtgcg) corresponds to the high
affinity binding site for Pho4p, the protein controlling
transcriptional response to Phosphate in yeast. the second alignment
(cgcacgttt) corresponds to the medium affinity binding site for
Pho4p. Medium affinity binding sites have been shown to participate in
the transcriptional response to some PHO genes.

\begin{verbatim}
more PHO_up800_6nt_2str_ncf_sig0.assemb
\end{verbatim}

\subsubsection{Suboptimal settings}

This chapter only aims at emphasizing how crucial is the choice of
appropriate statistical parameters. we saw above that the optimal
parameters give good results with the PHO family: despite the
simplicity of the algorithm (counting non-degenerate hexanucleotide
occurrences), we were ablt to extract a description of the regulatory
motif over a larger width than 6 (by pattern assembly), and we got
some decription of the degeneracy (the high and low affinity stes).

We will now intentionally try other parameter settings and see how
they affect the quality of the results.

\textit{\textbf{Equiprobable oligonucleotides}}

Let us try the simplest approach: each word is considered
equiprobable. For this, we simply suppress the options \texttt{-ncf -org
yeast} fom the above commands. We also ommit to specify the output
file, so results will immediately apper on the screen.

\begin{verbatim} 
oligo-analysis -i PHO_up800.fasta -format fasta \ 
    -v -l 6 -2str \
    -return occ,proba -thosig 0 -sort 
\end{verbatim}

Note that
\begin{itemize} 
\item The number of selected motifs is higher (27) than in the previous trial
\item The most significant motifs have nothing to with Pho4p binding
sites. All these false positive are A-rich motifs (or T-rich, since we
are grouping patterns with their reverse-complement).
\item Two patterns (\texttt{acgttt} and \texttt{acgtgc}) are selected
which are related to Pho4p binding site. However, they come at the
12th and 14th positions only.
\end{itemize}

You can combine oligo-analysis and pattern-assembly in a single
command, by using the pipe character as below.

\begin{verbatim}
oligo-analysis -i PHO_up800.fasta -format fasta -v \
    -l 6 -2str  -return occ,proba -thosig 0 -sort \
    | pattern-assembly -2str -sc 7 -subst 1 -v
\end{verbatim}

On unix systems, this special character is used to concatenate
commands, i.e. the output of the first command (in this case
oligo-analysis) is not printed to the screen, but is sent as input for
the second command (in this case pattern-assembly).

Note that the most significant patterns are associated to the poly-A
(aaaaaa) contig. The true positive come isolated. due to the bad
choice of expected frequencies (all hexanucleotides were considered
equiprobable here), regulatory sites were lost within a majority of
false positive, and their description is much less accurate than with
the option \texttt{-ncf}.

\textit{\textbf{Markov chains}}

Another possibility is to use Markov chain models to estimate expected
word frequencies. Try the following commands and compare the
results. None is as good as the \texttt{-ncf} option, but in case one
would not have the pre-calibrated non-coding frequencies (for instance
if the organism has not been completely sequenced), markov chains can
provide an interesting approach.

\begin{verbatim}
oligo-analysis -markov 0 \
    -i PHO_up800.fasta -format fasta \
    -l 6 -thosig 0 -sort \
    -2str -return occ,proba \
    | pattern-assembly -2str -sc 7 -subst 1 -v

oligo-analysis -markov 1 \
    -i PHO_up800.fasta -format fasta \
    -2str -return occ,proba \
    -l 6 -thosig 0 -sort \
    | pattern-assembly -2str -sc 7 -subst 1 -v
	
oligo-analysis -markov 2 \
    -i PHO_up800.fasta -format fasta \
    -2str -return occ,proba \
    -l 6 -thosig 0 -sort \
    | pattern-assembly -2str -sc 7 -subst 1 -v
	
oligo-analysis -markov 3 \
    -i PHO_up800.fasta -format fasta \
    -2str -return occ,proba \
    -l 6 -thosig 0 -sort \
    | pattern-assembly -2str -sc 7 -subst 1 -v
	
oligo-analysis -markov 4 \
    -i PHO_up800.fasta -format fasta \
    -2str -return occ,proba \
    -l 6 -thosig 0 -sort \
    | pattern-assembly -2str -sc 7 -subst 1 -v
\end{verbatim}

\textit{\textbf{Remarks}}
\begin{itemize}
\item 
Markov 0 returns AT-rich patterns with the highest significance, but
the Pho4p high affinity site is described with a good accuracy. te
medium affinity site appears as a single word (acgttt) in the isolated
patterns.
\item 
Markov order 1 returns less AT-rich motifs. The poly-A (aaaaaa) is
however still associated with the highest significance, but comes as
isolated pattern.
\item 
The higher the order of the markov chain, the most stringent are the
conditions. For small sequence sets, selecting a too high order
prevents from selecting any pattern. Markov order 2 mises most of the
patterns, and higher orders don't return any single significant word.
\end{itemize}

\subsection{dyad-analysis}



\subsection{gibbs motif sampler (program developed by Andrew Neuwald)}




\subsection{consensus (program developed by Jerry Hertz)}

An alternative approach for matrix-based pattern discovery is
\textit{consensus}, a program written by Jerry hertz, an based on a
greedy algorithm. We will see how to extract a profile matrix from ths
upstream regions of the PHO genes.

\subsubsection{Getting help}

As for RSAT programs, there are two ways to get help from Jerry Hertz'
proigrams: a detailed manual can be obtained with the option
\texttt{-h}, and a summary of options with \texttt{-help}. Try these
options and read the manual.

\begin{verbatim}
consensus -h
consensus -help
\end{verbatim}

\subsubsection{Sequence conversion}


\textit{consensus} uses a custom sequence format. Fortunately, the RSAT
package contains a sequence conversion program (\textit{convert-seq})
which supports Jerry Hertz' format. We will thus start by converting
the fasta sequences in this format. 

\begin{verbatim}
convert-seq -i PHO_up800.fasta -from fasta -to wc \ 
    -o PHO_up800.wc
\end{verbatim}

\subsubsection{Running consensus}

Using consensus requires to chose the appropriate value for a series
of parameters. We found the following combination of parameters quite
efficient for discovering patterns in yeast upstream sequences.

\begin{verbatim}
consensus -L 10 -f PHO_up800.wc -A a:t c:g -c2 -N 10
\end{verbatim}

The two main options here is that we suppose that the pattern has a
length of about 10 bp (\texttt{-L 10}), and that we will find about 10
occurrences in the sequence set. Since there are 5 genes in the
family, this means that we expect on average 2 regulatory sites per
gene, which is generally a good guess for yeast.

Notice that several matrices are returned. Each matrix is followed by
the alignment of the sites on which it is based. Notice that the 4
matrices are highly similar, basically they are all made of several
occurrences of the high afinity site CACGTG, and mtrices 1 and 3
contain one occurrence of the medium affinity site CACGTT. 

Also notice that these matrices are not made of exactly 10 sites
each. \textit{consensus} is able to adapt the number of sites in the
alignment in order to get the highest information content. The option
\texttt{-N 10} was an indication rather than a rigid requirement.

To save the result in a file, you can use the symbol ``>'' which
redirects the output of a program to a file. 

\begin{verbatim}
consensus -L 10 -f PHO_up800.wc -A a:t c:g -c2 -N 10 \
    > PHO_consensus
\end{verbatim}

(this takes a few minuts). 

Once the task is achieved, check the result.

\begin{verbatim}
more PHO_consensus
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% PATTERN MATCHING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pattern matching}

In a pattern matching problem, you start from one or several
predefined patterns, and you match this pattern against a sequence,
i.e. you locate all occurrences of this pattern in the sequences.

Patterns can be represented as strings (with \textit{dna-pattern}) or
position-weight matrices (with \textit{patser}). 

\subsection{dna-pattern}

\textit{dna-pattern} is a string-based pattern matching program,
specialized for searching patterns in DNA sequences. 

\begin{itemize}

\item 
This specialization mainly consists in the ability to search on both
the direct and reverse complement strands.

\item 
A single run can either search for a single pattern, or for a list
of patterns.

\item 
multi-sequence file formats (fasta, filelist, wc, ig) are supported,
allowing to match patterns against a list of sequences with a single
run of the program.

\item 
String descriptions can be refined by using the 15-letters IUPAC code
for uncompletely specified nucleotides, or by using regular
expressions.

\item 
The program can either return a list of matching positions (default
behaviour), or the count of occurrences of each pattern.

\item 
Imperfect matches can be searched by allowing
substitutions. Insertions and deletions are not supported.  The reason
is that, when a regulatory site presents variations, it is generally
in the form of a tolerance for substitution at a specific position,
rather than insertions or deletions. It is thus essential to be able
distinguishing between these types of imperfect matches.

\end{itemize}


\subsubsection{Matching a single pattern}

We will start by searching all positions of a single pattern in a
sequence set. The sequence is the set of upstream regions from the PHO
genes, that was obtained in the tutorial on sequence retrieval. We
will search all occurrences of the most conserved core of the Pho4p
medium affinity binding site (\texttt{CACGTT}) in this sequence set.

Try the following command:

\begin{verbatim}
dna-pattern -i PHO_up800.fasta -format fasta \ 
    -1str -p cacgtt -id 'Pho4p_site'
\end{verbatim}

You see a list of positions for all the occurrences of CACGTT in the sequence.

Each row represents one match, and the columns provide the following
information:
\begin{enumerate}
\item pattern identiifier
\item strand
\item pattern searched
\item sequence identifier
\item start position of the match
\item end position of the match
\item matched sequence
\item matching score
\end{enumerate}

\subsubsection{Matching on both strands}

To perform the search on both strands, type:
\begin{verbatim}
dna-pattern -i PHO_up800.fasta -format fasta \ 
    -2str -p cacgtt -id 'Pho4p_site'
\end{verbatim}

Notice that the strand colmn now contains two possible values: D for
``direct'' and R for ``reverse complement''.

\subsubsection{Allowing substitutions}

To allow one substitutions, type:
\begin{verbatim}
dna-pattern -i PHO_up800.fasta -format fasta \
    -2str -p cacgtt -id 'Pho4p_site' -subst 1
\end{verbatim}

Notice that the score column now contains 2 values: 1.00 for perfect
matches, 0.83 (=5/6) for single substitutions. This si one possible
use of the score column: when substitutions are allowed, the score
indicates the percentage of matching nucleotides.

Actually, for regulatory patterns, allowing substitutions usually
returns many false positive, and this option is usually avoided. We
will not use it further in the tutorial.

\subsubsection{Extracting flanking sequences}

The matching positions can be extracted along with their flanking nucleotides. Try:

\begin{verbatim}
dna-pattern -i PHO_up800.fasta -format fasta \
     -2str -p cacgtt \
     -id  'Pho4p_site' -N 4
\end{verbatim}

Notice the change in the matched sequence column: each matched
sequence contains the pattern CACGTT in uppercase, and 4 lowercase
letters on each side (the flanks).

\subsubsection{Changing the origin}

When working with upstream sequences, it is convenient to work with
coordinates relative to the start codon (i.e. the right side of the
sequence). Sequence matching programs (including dna-pattern) return
the positions relative to the beginning (i.e. the left side) of the
sequence. The reference (coordinate 0) can however be changed iwith
the option \texttt{-origin}. In this case, we retrieved upstream
sequences over 800bp. the start codon is thus located at position
801. Try:

\begin{verbatim}
dna-pattern -i PHO_up800.fasta -format fasta \
    -2str -p cacgtt \
    -id  'Pho4p_site' -N 4 -origin 801
\end{verbatim}

Notice the change in coordinates.

In some cases, a sequence file will contain a mixture of sequences of
different length (for example if one clipped the sequences to avoid
upstream coding sequences). The origin should thus vary from sequence
to sequence. A convenient way to circumvent the problem is to use a
egative value with the option \texttt{origin}. for example,
\texttt{-origin -100} would take as origin the 100th neucleotide
starting from the right of each sequence in the sequence file. But in
our case we want to take as origin the position immediately after the
last nucleotide. For this, there is a special convention: \texttt{-origin
-0}.

\begin{verbatim}
dna-pattern -i PHO_up800.fasta -format fasta \
    -2str -p cacgtt \
    -id  'Pho4p_site' -N 4 -origin -0
\end{verbatim}

In the current example, since all sequences have exactly 800bp length,
the result is identical to the one obtained with \texttt{-origin 801}.

\subsubsection{Matching degenerate patterns}

As we said before, there are two forms of Pho4p binding sites: the
protein has high affinity for motifs containing the core CACGTG, but
can alos bind, with a medium affinity, CACGTT sites. The IUPAC code
for partly specified nucleotides allows to represent any combination
of nucleotids by a single letter.

\begin{tabular}{lll}
\textbf{A} &  & (Adenine) \\
\textbf{C} &  & (Cytosine) \\
\textbf{G} &  & (Guanine) \\
\textbf{T} &  & (Trymine) \\
\textbf{R} & = A or G & (puRines) \\
\textbf{Y} & = C or T & (pYrimidines) \\
\textbf{W} & = A or T & (Weak hydrogen bonding) \\
\textbf{S} & = G or C & (Strong hydrogen bonding) \\
\textbf{M} & = A or C & (aMino group at common position) \\
\textbf{K} & = G or T & (Keto group at common position) \\
\textbf{H} & = A, C or T & (not G) \\
\textbf{B} & = G, C or T & (not A) \\
\textbf{V} & = G, A, C & (not T) \\
\textbf{D} & = G, A or T & (not C) \\
\textbf{N} & = G, A, C or T & (aNy) \\
\end{tabular}

Thus, we could use the string CACGT\textbf{K} to represent the Pho4p
consensus, and search both high and medium affinity sites in a single
run of the program.

\begin{verbatim}
dna-pattern -i PHO_up800.fasta -format fasta \
    -2str -p cacgtk \
    -id  'Pho4p_site' -N 4 -origin -0
\end{verbatim}

\subsubsection{Matching regular expressions}

Another way to represent partly specified strings is by using regular
expressions. This not only allows to represent combinations of letters
as we did above, but also spacings of variable width. For example, we
could search for tandem repeats of 2 Pho4p binding sites, separated by
less than 100bp. This can be represented by the following regular expression: 

\begin{verbatim}
cacgt[gt].{0,100}cacgt[gt]
\end{verbatim}

which means
\begin{itemize}
\item cacgt 
\item followed by either g or t [gt]
\item followed by 0 to 100 unspecified letters .{0,100}
\item followed by cacgt
\item followed by either g or t [gt]
\end{itemize}

Let us try to use it with dna-pattern

\begin{verbatim}
dna-pattern -i PHO_up800.fasta -format fasta \
    -2str -id 'Pho4p_pair' \
    -N 4 -origin -0 \
    -p 'cacgt[gt].{0,100}cacgt[gt]'
\end{verbatim}


Note that the pattern has to be quoted, to avoid possible conflicts
between special characters used in the regular expression and the unix
shell.


\subsubsection{Matching several patterns}

TO match a series of patterns, you first need to store these patterns
in a file. Let create a pattern file:

\begin{verbatim}
cat > test_patterns.txt
cacgtg	high
cacgtt	medium
\end{verbatim}
(then tpye Ctrl-d to close)

check the content of your pattern file.
\begin{verbatim}
more test_patterns.txt
\end{verbatim}

There are two lines, each representing a pattern. The first word of
each line contains the pattern, the second word the identifier for
that pattern. This column can be left lank, in which case the pattern
is used as identifier.

We can now use this file to search all matching psitions of both
patterns in the PHO sequences.

\begin{verbatim}
dna-pattern -i PHO_up800.fasta -format fasta \
    -2str  -N 4 -origin -0 \
    -pl test_patterns.txt
\end{verbatim}

\subsubsection{Counting pattern matches}

In the previous examples, we were interested in matching positions. It
is sometimes interesting to get a more synthetic information, in the
form of a count of matching positions for each sequences. Try:

\begin{verbatim}
dna-pattern -i PHO_up800.fasta -format fasta \ 
     -2str  -N 4 -origin -0 -c \
     -pl test_patterns.txt
\end{verbatim}

With the option \texttt{-c}, the program returns the number of
occurrences of each pattern in each sequence. The output format is
different: there is one row for each combination pattern-sequence. Te
columns indicate respectively
\begin{enumerate}
\item sequence identifier
\item pattern identifier
\item pattern sequence
\item match count
\end{enumerate}

An even more synthetic result can be obtained with the option
\texttt{-ct} (count total).

\begin{verbatim}
dna-pattern -i PHO_up800.fasta -format fasta -2str \
    -pl test_patterns.txt -N 4 -origin -0 -ct
\end{verbatim}

This time, only two rows are returned, one per pattern. 

\subsubsection{Getting a count table}

Anothe rway to display the count information is in the form of a
table, where each row represents a gene and each column a pattern.

\begin{verbatim}
dna-pattern -i PHO_up800.fasta -format fasta -2str \
    -pl test_patterns.txt -N 4 -origin -0 -table
\end{verbatim}

This representation is very convenient for aplying multivariate
statistics on the results (e.g. classificatying genes according to the
patterns found in their upstream sequences)

Last detail: we can add one column and one row for the totals per
gene and per pattern.

\begin{verbatim}
dna-pattern -i PHO_up800.fasta -format fasta -2str \
    -pl test_patterns.txt -N 4 -origin -0 -table -total
\end{verbatim}




\subsection{patser (program developed by by Jerry Hertz)}

We will now see how to match a profile matrix against a sequence
set. For this, we use \textit{patser}, a program written by Jerry
Hertz. 

\subsubsection{Getting help}

help can be obtained with the two usual options.

\begin{verbatim}
patser -h
patser -help
\end{verbatim}

\subsubsection{Matrix conversion}

Patser expects as input a matrix like the 4 matrices we obtained above
with \textit{consensus}. The output from \textit{consensus} can however
not be used directly because it contains several matrices, and a lot
of additional information. One possibility is to copy-paste the matrix
of interest to a separate file.

To avoid manual editing, RSAT contains a program
\textit{matrix-from-consensus}, which automaticaly extacts the first
matrix from a consensus output.

\begin{verbatim}
matrix-from-consensus -i PHO_consensus -o PHO_matrix
more PHO_matrix
\end{verbatim}


\subsubsection{Detecting Pho4p sites in the PHO genes}

After having extracted the matrix, we can match it against the PHO
sequences to detect putative regulatory sites.

\begin{verbatim}
patser -m PHO_matrix -f PHO_up800.wc -A a:t c:g -c -l 9
\end{verbatim}

\subsubsection{Detecting Pho4p sites in all upstream regions}

We will now match our PHO matrix against the whole set of upstream
regions from the 6200 yeast genes. This should allow us to detect new
genes potentially regulated by Pho4p.

One possibility would be to use \textit{retrieve-seq} to extract all
yeast upstream regions, and save the result in a file, which will then
be used as input by \textit{patser}. To avoid occupying too much space
on the disk, we could combine both tasks in a single command, and
immediately redirect the output of \textit{retrieve-seq} as input for
\textit{patser}. This can be done with the pipe character as below. 


\begin{verbatim}
retrieve-seq -type upstream -from -1 -to -800  \
    -org Saccharomyces_cerevisie \
    -all -format wc -label gene  \
    | patser -m PHO_matrix -l 9 -A a:t c:g
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% DRAWING GRAPHS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Drawing graphs}

\subsection{Accessing graphs in your account from the web}

\subsection{feature-map}

\subsection{XYgraph}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% UTILITIES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Utilities}

\subsection{orf-info}

\textbf{orf-info} allows you to get information on ORFs, given a series of
query words. Queries are matched against ORF identifiers and ORF
names. Imperfect matches can be specified by using regular
expressions.

For example, to get all info about the yeast gene GAT1:

\begin{verbatim}
orf-info -org Saccharomyces_cerevisie -q GAT1
\end{verbatim}

And to get all the purine genes from \textit{Escherichia coli}, type: 

\begin{verbatim}
orf-info -org Escherichia_coli_K12 -q 'pur.*'
\end{verbatim}

Note the use of quotes, which is necessary whenever the query contains
a *.

You can also combine several queries on the same command line, by
using reiteratively the -q option:

\begin{verbatim}
orf-info -org Escherichia_coli_K12 \
    -q 'met.*' -q 'thr.*' -q 'lys.*'
\end{verbatim}

\subsection{On-the-fly compression/uncompression}
All programs from \RSAT support automatic compression and
uncompression of gzip files. This can be very convenient when dealing
with big sequence files.

To compress the result of a query, simply add the extension
\texttt{.gz} to the output file name.

\begin{verbatim}
retrieve-seq -all -org Saccharomyces_cerevisiae \
        -from -1 -to -200 -noorf -format fasta \
        -o all_up200.fta.gz
\end{verbatim}

The result file is a compressed archive. Check its size with the
command 
\begin{verbatim}
ls -l
\end{verbatim}

Uncompress the file with the command 
\begin{verbatim}
gunzip all_up200.fta.gz
\end{verbatim}

The file has now lost the \texttt{.gz} extension. Check the size of the
uncompressed file.

Recompress the file with the command
\begin{verbatim}
gzip all_up200.fta
\end{verbatim}

Similarly, you can directly use a compressed archive as input for
\RSAT, it will be uncompressed on the fly, without occupying space on
the hard drive. For example :

\begin{verbatim}
dna-pattern -i all_up200.fta.gz -p GATAAG -c -th 3
\end{verbatim}

will return all the genes hacing at least three occurrences f the
motif \texttt{GATAAG} in their 200 bp upstream region.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% EXERCISES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Exercises}

As an exercise, we will now combine the different tools described
above to analyse the full set of promoters from \organism{Arabidopsis
thaliana}. We define ourselves the following goals :
\begin{enumerate}
\item Discover motifs which are over-represented in the complete set
of upstream sequences for the selected organism. 
\item Try different parameters for this pattern discovery, and compare
the results.
\item Use these over-represented patterns to scan full chromosomes
with a sliding window, to evaluate if we can predict promoter
locations on the sole basis of pattern occurrences. find optimal
parameters for the prediction of promoter locations.
\end{enumerate}

\subsection{Some hints}

\subsubsection{Sequence retrieval}

The first step will be to retrieve the full complement of upstream
sequences. Since we have no precise idea about the best sequence size,
we will try several reasonable ranges, each roughly corresponding to a
given functionality.

\begin{description}
\item[from -1 to -200] this regions is likey to contain mostly 5'UTR.
\item[from -1 to -400] this region is likely to contain the 5' UTR and
the proximal promoter.
\item[from -1 to -1000] this region is likely to include the 5'UTR,
as well as the proxima and distal promoters. 
\item[from -1 to -2000] an even larger range, which probably contains
most of the upstream cis-acting elements in \organism{A. thaliana}.
\end{description}

In all cases, we will clip upstream ORFs, because they would bias the
oligonucleotide composition.

Write the commands which will retrieve all upstream sequences over the
specified range. Beware, the sequence files may occupy a large space
on the disk, it is probably wise to directly compress them by adding
the extension \texttt{.gz} to the output file.

\subsubsection{Detection of over-represented motifs}

In a first step, we will restrict our analysis to
hexanucleotides. Once all the subsequent steps (full chromosome
scanning) will be accomplished, we will redo the complete analysis
with different oligonucleotide lengths, and compare the efficiency of
promoter prediction.

Detect over-represented oligo-nucleotides with different estimators of
expected frequencies: Markov chains of different orders, non-coding
frequencies. 

Do not forget to prevent counting self-overlapping matches.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliographic references
\section{References}

\begin{enumerate}

\item van Helden, J., Andre, B. \& Collado-Vides, J. (1998). Extracting
regulatory sites from the upstream region of yeast genes by
computational analysis of oligonucleotide frequencies. J Mol Biol
281(5), 827-42. 

\item van Helden, J., André, B. \& Collado-Vides, J. (2000). A web site
for the computational analysis of yeast regulatory sequences. Yeast
16(2), 177-187.

\item van Helden, J., Olmo, M. \& Perez-Ortin, J. E. (2000). Statistical
analysis of yeast genomic downstream sequences reveals putative
polyadenylation signals. Nucleic Acids Res 28(4), 1000-1010.

\item van Helden, J., Rios, A. F. \& Collado-Vides,
J. (2000). Discovering regulatory elements in non-coding sequences by
analysis of spaced dyads. Nucleic Acids Res. 28(8):1808-18. 

\item van Helden, J., Gilbert, D., Wernisch, L., Schroeder, M. \& Wodak,
S. (2001). Applications of regulatory sequence analysis and metabolic
network analysis to the interpretation of gene expression
data. Lecture Notes in Computer Sciences 2066: 155-172. 

\item van Helden, J. (2002). Prediction of transcriptional regulation
by analysis of the non-coding genome. Current Genomics \textit{in
press}.


\end{enumerate}

\end{document}