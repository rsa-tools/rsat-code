#!/usr/bin/perl -w
############################################################
#
# $Id: variation-scan,v 1.8 2013/08/09 09:23:26 jeremy Exp $
#
############################################################

## use strict;


=pod

=head1 NAME

retrieve-variation-seq

=head1 VERSION

$program_version

=head1 DESCRIPTION

Scan sequence with different matrice weigth-position of transcription factor


=head1 AUTHORS

Jeremy.Delerce@univ-amu.fr

=head1 CATEGORY

=over

=item util

=back

=head1 USAGE

 variation-scan [-i sequence_file] -m matrix_file -bg backgournd_file [-calc_distrib] [-o outputfile] [-v #] [...]

=head2 Example


=head1 INPUT FORMAT

=head2 Sequence file

See I<retrieve-variation-seq> output format.

=head2 Matrix file

A list  of matrix in transfanc format

=head2 Background file

Oligo-analysis format

=head1 OUTPUT FORMAT

A tab delimited file with the following column content.

=over

=item 1. matrix

Name of the matrice

=item 2. variation

Name of the variation

=item 3. SO

SO term of the variation.

=item 4. coord

Coordinate of the variation.

=item 5. B_weight

Best max weigth. 

=item 8. W_weight

Worst max weigth.

=item 7. Diff

Difference between the two max weigth.

=item 8. variant

Variant of the variation in the sequence.

=item 9. B_pval

Pvalue of the best max weigth.

=item 10. W_pval

Pvalue of the worst max weigth.

item 11. sigma

Log10 difference between the two p-value.

item 12. B_var

Variant(s) in the sequence with the best max weigth.

Multiple variant are return comma separate if the highest max weigth
 is the same in multiple sequence.

item 13. W_var

Variant(s) in the sequence with the worst max weigth.

Multiple variant are return comma separate if the lowest max weigth
 is the same in multiple sequence.

item 14. B_coord

Coordinate(s) of the matrix in the sequence with the best max weigth.

Multiple coordinate are return comma separate if the best max weigth
 is the same in multiple sequence.

item 15. W_coord

Coordinate(s) of the matrix in the sequence with the worst max weigth.

Multiple coordinate are return comma separate if the worst max weigth
 is the same in multiple sequence.

item 14. B_seq

Sequence with the highest max weigth.

Multiple sequence are return comma separate if the best max weigth
 is the same in multiple sequence.

item 15. W_seq

Sequence with the lowest max weigth.

Multiple sequence are return comma separate if the worst  max weigth
 is the same in multiple sequence.
 
=back

=head1 SEE ALSO

=head2 download-ensembl-genome

I<retrieve-variation-seq> uses the sequences downloaded
from Ensembl using the tool I<download-ensembl-genome>.

=head2 download-ensembl-variations

I<retrieve-variation-seq> uses variation coordinates downloaded
from Ensembl using the tool I<download-ensembl-variations>.

=head2 variation-scan

Scan variation sequences with one or several position-specific scoring
matrices.

=head1 WISH LIST

=cut

BEGIN {
  if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
  }
}

require "RSA.lib";


################################################################
## Main package
package	main;
{

  ###############################################################
  ## Initialise parameters
  our $start_time = &RSAT::util::StartScript();
  our $program_version = do { my @r = (q$Revision: 1.8 $ =~ /\d+/g); sprintf"%d."."%02d" x $#r, @r };

  our %infile	= ();
  $infile{'distrib_list'} = "";
  our %outfile = ();

  our $verbose = 0;
  our $in = STDIN;
  our $out = STDOUT;

  our %matrix_list = ();
  our %matrix_PWM = ();
  our $flank_len = 29;
  our $only_biggest = 0;
  our $pval_limit = 1;

  our $calc_distrib = 0;
  our $distrib_dir = "";

  our $html = 0;
  our $top_matrix =-1;
  our $top_variation = -1;

  ################################################################
  ## Read argument values
  &ReadArguments();
  $out = &OpenOutputFile($outfile{output});

  ###############################################################
  ## Check arguments
  &RSAT::error::FatalError("You forgot to indicate a background file. Use -bg option") unless ($infile{'bg'});
  &RSAT::error::FatalError("You forgot to indicate a matrix file. Use -m option") unless ($infile{'matrixfile'});
  &RSAT::error::FatalError("Background file",$infile{'bg'},"does not exist") unless (-f $infile{'bg'});
  &RSAT::error::FatalError("Matrice file",$infile{'matrixfile'},"does not exist") unless (-f $infile{'matrixfile'});
  
  if ($calc_distrib) {
    &RSAT::error::FatalError("You forgot to indicate distribution directory. Use -distrib_dir option") unless ($distrib_dir);
    &RSAT::message::TimeWarn("Calculing distribution") if ($main::verbose >= 2);

    my @bg_name = split('/',$infile{'bg'});
    @bg_name = split('.',$bg_name[-1]);
    my $bg_name = $bg_name[-1];
    $outfile{'distrib_list'} = $bg_name."_list.tab";

    &Verbose() if ($main::verbose >= 1);

    my $split_dir = $distrib_dir."/split_dir/tmp";
    &RSAT::util::CheckOutDir($split_dir);

    &doit($ENV{'RSAT'}."/perl-scripts/convert-matrix -v 1 -from tf -to tf -split -i $infile{'matrixfile'} -o $split_dir", 0, 0, 0);


    my $outD = &OpenOutputFile($distrib_dir.'/'.$outfile{'distrib_list'});
    print $outD "#MATRIX_ID\tDISTRIB_FILE\tDB\tBG_PREFIX";

    my ($file) = &OpenInputFile($split_dir.'_matrix_list.tab');
    while (<$file>) {
      next if (/^#/); ## Skip comment lines
      next if (/^;/); ## Skip RSAT-like comment lines
      next unless (/\S/); ## Skip empty lines
      chomp();
      my @token = split("\t");
      my $distrib_file = $token[1]."_".$bg_name.".tab";

      &doit($ENV{'RSAT'}."matrix-distrib -m $token[2] -matrix_format tf -decimals 1 -bgfile $infile{'matrixfile'} -bg_pseudo 0.01 -bg_format oligos -pseudo 1 -o $distrib_dir/$distrib_file", 0, 0, 0);
      print $outD $token[1],"\t",$distrib_file,"\t.\t",$bg_name,"\n";
    }
    &RSAT::message::Info("Distrib_list :", $distrib_dir.'/'.$outfile{'distrib_list'}) if ($main::verbose >= 2);

    ################################################################
    ## Report execution time and close output stream
    my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts
    print $out $exec_time  if ($main::verbose >= 1); ## only report exec time if verbosity is specified
    close $out;

    exit(0);
  }

  if ($infile{'distrib_list'}) {
    &RSAT::error::FatalError("Distrib list",$infile{'distrib_list'},"file does not exist") unless (-f $infile{'distrib_list'});
  }


  ################################################################
  ## Print verbose
  &Verbose() if ($main::verbose >= 1);
  print $out "#motif\tvar_id\tvar_class\tcoord\thBw\tWw\tw_diff\tB_pval\tW_pval\tpval_ratio\tpval_lr\tpval_lr_relatif\tB_var\tW_var\tB_pos\tW_pos\tmin_offset\tstr_ch\tB_seq\tW_seq\n";

  ################################################################
  #Read Matrix File
  &RSAT::message::TimeWarn("Reading Matrix File") if ($main::verbose >= 2);

  my $length = 0;
  my $need_count = 0;
  my $ac = "";
  my $nb_matrix = 0;

  my ($mat_file) = &OpenInputFile($main::infile{'matrixfile'});
  while (<$mat_file>) {
    next if (/^#/); ## Skip comment lines
    next if (/^;/); ## Skip RSAT-like comment lines
    next unless (/\S/); ## Skip empty lines
    chomp();

    my @token = split (" ",$_);

    if ( $token[0] eq "AC") {
      $ac = $token[-1];
      $length = 0;
    }

    if ( $token[0] eq "ID" ) {
      $matrix_list{$ac}{'id'} = $token[-1];
    }

    $need_count = 0 if ( $token[0] eq "XX" );

    if ($need_count) {
      $length += 1;

      for (my $i = 1;$i < scalar(keys(%{$matrix_list{$ac}{'tab'}})+1);$i++ ) {
        push ( @{ $matrix_list{$ac}{'tab'}{$i} }, $token[$i] );
      }
    }

    if ( $token[0] eq "P0" ||$token[0] eq "PO" ) {
      $need_count = 1;

      for (my $i = 1;$i < scalar(@token);$i++ ) {
        push ( @{ $matrix_list{$ac}{'tab'}{$i} }, lc($token[$i]) );
      }
    }

    if ( $token[0] eq "//") {
      $matrix_list{$ac}{'length'} = $length;
      $nb_matrix++;
    }

    if ($top_matrix) {
      last if ($top_matrix == $nb_matrix && $top_matrix > 0);
    }

  }
  $matrix_list{$ac}{'length'} = $length;
  close $mat_file;

  ## Get distrib files
  my %distrib_file_list = ();
  if ( -f $infile{'distrib_list'} ) {
    my $distrib_file_name = "";
    ($distrib_dir, $distrib_file_name) = &SplitFileName($infile{'distrib_list'});

    ($file) = &OpenInputFile($infile{'distrib_list'});
    while (<$file>) {
      next if (/^#/); ## Skip comment lines
      next if (/^;/); ## Skip RSAT-like comment lines
      chomp();
      my @token = split("\t");
      $distrib_file_list{$token[0]} = $token[1];
    }
  }

  ################################################################
  my $fasta_file = &RSAT::util::make_temp_file("","variation-scan_fasta_seq", 1);
  my $bg_file = &RSAT::util::make_temp_file("","variation-scan_bg_file", 1);
  my $matrix_file_tab = &RSAT::util::make_temp_file("","variation-scan_matrices_tab", 1);
  my $variation_seq = &RSAT::util::make_temp_file("","variation-scan_variant_seq_tab", 1);

  ## Change bg_file format
  my $command = "$ENV{'RSAT'}/perl-scripts/convert-background-model -i $main::infile{'bg'} -from oligos -to inclusive -o $bg_file -bg_pseudo 0.01";
  &doit($command, 0, 0, 0);

  ## Write pipe input into fie for multipl read
  unless ($main::infile{input}) {
    my $outstream_var_seq = &OpenOutputFile($variation_seq); 
    while (<$main::in>) {
      next if (/^#/); ## Skip comment lines
      next if (/^;/); ## Skip RSAT-like comment lines
      next unless (/\S/); ## Skip empty lines
      next unless (/\t/); ## Skip lines containing no tab (likely to be starting comment lines)
      print $outstream_var_seq $_;
    }
    close $outstream_var_seq;
    $main::infile{input} = $variation_seq;
  }


  ## Scan
  our $matrix_length = 0;

  foreach my $matrix_ac (keys(%matrix_list)) {
    $matrix_length = $matrix_list{$matrix_ac}{'length'};
    next if ($matrix_length == 0);
    next if ($matrix_length > $flank_len+1);

    ## Make matrix file on tab format
    my $outM = &OpenOutputFile($matrix_file_tab);
    foreach my $line (sort {$a <=> $b} keys( %{ $matrix_list{$matrix_ac}{'tab'} } )) {
      print $outM join("\t",@{$matrix_list{$matrix_ac}{'tab'}{$line}})."\n";
    }
    close($outM);

    ## Get distribution
    &RSAT::message::TimeWarn("\tGet distrib") if ($main::verbose >= 3);

    %matrix_info = ();

    # Use precalculte distrib file
    if ($distrib_file_list{$matrix_ac}) {
      my %legend_col = ();

      my $distrib_file = $distrib_dir."/".$distrib_file_list{$matrix_ac};
      my ($d_file) = &OpenInputFile($distrib_file);
      while (<$d_file>) {
        next if (/;/);
        chomp;

        if (/^#/) {
          $_ = substr($_,1) ;
          my @legends = split("\t");
          for (my $i = 0; $i < scalar(@legends);$i++) {
            $legend_col{$legends[$i]} = $i;
          }
        } else {
          my @value = split("\t");
          $matrix_info{$matrix_ac}{'pval'}{$value[$legend_col{"weight"}]} = $value[$legend_col{"Pval"}];
        }
      }

      $matrix_info{$matrix_ac}{'pval'}{'0'} = $matrix_info{$matrix_ac}{'pval'}{'0.0'};
      $matrix_info{$matrix_ac}{'pval'}{'-0.0'} = $matrix_info{$matrix_ac}{'pval'}{'0.0'};

      my @sorted_pval = sort {$a <=> $b} keys (%{$matrix_info{$matrix_ac}{'pval'}});
      $matrix_info{$matrix_ac}{'sigma_max'} = log10($matrix_info{$matrix_ac}{'pval'}{$sorted_pval[0]}/$matrix_info{$matrix_ac}{'pval'}{$sorted_pval[-1]});

    # Calcul distrib file
    } else {
      my %legend_col = ();
      my $arg = "-m $matrix_file_tab -matrix_format tab";
      $arg .= " -decimals 1 -pseudo 1";
      $arg .= " -bgfile $main::infile{'bg'} -bg_format oligos";
      $arg .= " -bg_pseudo 0.01";

      my @result_distrib = qx{$ENV{'RSAT'}/perl-scripts/matrix-distrib $arg};

      foreach (@result_distrib) {
        chomp;

        if (/^#/) {
          $_ = substr($_,1) ;
          my @legends = split("\t");
          for (my $i = 0; $i < scalar(@legends);$i++) {
            $legend_col{$legends[$i]} = $i;
          }
          next;
        }

        my @value = split("\t");
        $matrix_info{$matrix_ac}{'pval'}{$value[$legend_col{"weight"}]} = $value[$legend_col{"Pval"}];
      }

      $matrix_info{$matrix_ac}{'pval'}{'0'} = $matrix_info{$matrix_ac}{'pval'}{'0.0'};
      $matrix_info{$matrix_ac}{'pval'}{'-0.0'} = $matrix_info{$matrix_ac}{'pval'}{'0.0'};

      my @sorted_pval = sort {$a <=> $b} keys (%{$matrix_info{$matrix_ac}{'pval'}});
      $matrix_info{$matrix_ac}{'sigma_max'} = log10($matrix_info{$matrix_ac}{'pval'}{$sorted_pval[0]}/$matrix_info{$matrix_ac}{'pval'}{$sorted_pval[-1]});
    }

    ## Scan sequences
    my $last_id = "";
    my $nb_variation = 0;
    my $last_nb = 2000;

    $arg = " -i $fasta_file";
    $arg .= " -m $matrix_file_tab";
    $arg .= " -pseudo 1 -decimals 1 -2str -origin start";
    $arg .= " -bgfile $bg_file";
    $arg .= " -name $matrix_ac";

    &RSAT::message::TimeWarn("\tScan matrix") if ($main::verbose >= 3);
    my $out_fas = &OpenOutputFile($fasta_file);

    my ($var_seq) = &OpenInputFile($main::infile{input});
    while (<$var_seq>) {
      next if (/^#/); ## Skip comment lines
      next if (/^;/); ## Skip RSAT-like comment lines
      next unless (/\S/); ## Skip empty lines
      next unless (/\t/); ## Skip lines containing no tab (likely to be starting comment lines)
      chomp();

      my ($chrom, $start, $end,$strand,$id,$type,$ref,$variant,$seq) = split(/\t/);

      $ref = "-" if ($ref eq "");

      if ($last_id ne $id && $last_id ne "") {
        $nb_variation ++;
        last if ($nb_variation > $top_variation && $top_variation>0);

        if ($nb_variation >= $last_nb) {
          my @scanning = qx{$ENV{'RSAT'}/contrib/matrix-scan-quick/matrix-scan-quick $arg};
          &Analyse(@scanning) unless (scalar(@scanning) == 0);

          close($out_fas);
          $out_fas = &OpenOutputFile($fasta_file);
          $last_nb += 2000;
        }
      }

      print $out_fas ">$id;$ref;$variant;$type|$chrom:$start-$end\_$strand\n".substr($seq,$flank_len-$matrix_length+1,length($seq)-($flank_len-$matrix_length+1)*2)."\n";
      $last_id = $id;
    }
    close ($var_seq);

    close($out_fas);
    my @scanning = qx{$ENV{'RSAT'}/contrib/matrix-scan-quick/matrix-scan-quick $arg};
    &Analyse(@scanning) unless (scalar(@scanning) == 0);
    @scanning = ();

    $out_fas = &OpenOutputFile($fasta_file); ##Just to make empty file
    close($out_fas);

  }

  ################################################################
  ## Report execution time and close output stream
  my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts
  print $out $exec_time  if ($main::verbose >= 1); ## only report exec time if verbosity is specified
  close $out;

  ################################################################
  ## Make html output
  if ($outfile{'output'} && $html) {
    $html_file = $outfile{'output'};
    $html_file =~ s/\.tab/\.html/g;
    $command = "$ENV{'RSAT'}/perl-scripts/text-to-html -i $outfile{'output'} -o $html_file";
    &doit($command, 0, 0, $verbose);
  }

  exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################

################################################################
## Display full help message
sub PrintHelp {
  system "pod2text -c $0";
  exit(0);
}

################################################################
## Display short help message
sub PrintOptions {
  &PrintHelp();
}
################################################################
## Calclate log10
sub log10 {
  my $n = shift;
  return log($n)/log(10);
}

################################################################
##
sub getLineInfo {
  my ($var_info1,$site,$matrice,$stran,$pos_s,$pos_e,$seq,$score) = split ("\t",$_[0]);
  my ($var_info2, $coord) = split(/\|/,$var_info1);
  my ($chr,$start_end_strand) = split(/:/,$coord);
  my ($start,$end_strand) = split(/-/,$start_end_strand);
  my ($id,$ref,$var,$type) = split(';',$var_info2);

  $diff_pos = ($start-$matrix_length);
  $diff_pos ++ if ($var eq "-"); 
  $pos_s += $diff_pos;
  $pos_e += $diff_pos;

  return ($matrice,$coord,$id,$type,$ref,$var,$stran,$pos_s,$pos_e,$seq,$score)
}

################################################################
## Analyse result of scanning
sub Analyse() {
  @scanning = @_;

  my %last_line = ();
  my %score_variation = ();

  while ( my $line = shift @scanning ) {
    
    next if ($line =~ m/^#/);
    next if ($line =~ m/^;/);
    chomp($line);

    my @info = &getLineInfo($line);
    my $same_matrice   =  !$last_line{'matrice'} || $info[0] eq $last_line{'matrice'};
    my $same_variation =  !$last_line{'variation'} || $info[2] eq $last_line{'variation'};
    my $same_variant   =  !$last_line{'variant'} || $info[5] eq $last_line{'variant'} ;

    $info[10] = sprintf("%.1f",$info[10]);

    if ($same_matrice && $same_variation && $same_variant) {
      my $same_score = 0;
      my $highest_score = 1;

      if ($score_variation{$info[5]}{'score'}) {
        $same_score = $score_variation{$info[5]}{'score'} == $info[10];
        $highest_score = $score_variation{$info[5]}{'score'} < $info[10];
      }

      if ( $highest_score ) {
        $score_variation{$info[5]} = ();
        $score_variation{$info[5]}{'score'} = $info[10];
        push(@{$score_variation{$info[5]}{'coord'}}, $info[7]."-".$info[8]."_".$info[6]);
        push(@{$score_variation{$info[5]}{'seq'}}, $info[9]);

      } elsif ($same_score) {
        $score_variation{$info[5]}{'score'} = $info[10];
        push(@{$score_variation{$info[5]}{'coord'}}, $info[7]."-".$info[8]."_".$info[6]);
        push(@{$score_variation{$info[5]}{'seq'}}, $info[9]);
      }


    } elsif ( !$same_matrice || !$same_variation ) {
      &PrintResult($last_line{'matrice'},$last_line{'variation'},$last_line{'SOterm'},$last_line{'coord'},\%score_variation );
      %score_variation = ();
    }

    $last_line{'matrice'} = $info[0];
    $last_line{'variation'} = $info[2];
    $last_line{'SOterm'} = $info[3];
    $last_line{'coord'} = $info[1];
    $last_line{'variant'} = $info[5];
  }

  &PrintResult($last_line{'matrice'},$last_line{'variation'},$last_line{'SOterm'},$last_line{'coord'},\%score_variation );
}

################################################################
## Sent print request for each diff between score of variant
sub PrintResult {
  my ($matrice,$variation,$so_term,$coord,$score_variation) = @_;
  my %score_variation = %{ $score_variation };

  my %score_variant = ();
  foreach my $variant ( keys(%score_variation) ) {
    push (@{ $score_variant{ $score_variation{$variant}{'score'} }{'variant'} }, $variant);
    push (@{ $score_variant{ $score_variation{$variant}{'score'} }{'coord'} }, join(",",@{$score_variation{$variant}{'coord'}}));
    push (@{ $score_variant{ $score_variation{$variant}{'score'} }{'seq'} }, join(",",@{$score_variation{$variant}{'seq'}}));
  }

  my @sorted_score = sort {$b <=> $a} keys(%score_variant);
  foreach my $score (@sorted_score) {
    next if ( ($score == $sorted_score[-1]) && (scalar(@sorted_score) > 1) );
    my $diff1 = $sorted_score[0] - $score;
    my $diff2 = $score - $sorted_score[-1];

    if ($matrix_info{$matrice}{'pval'}{$sorted_score[0]} <= $pval_limit) {
      if ($diff1 > $diff2 ) {
        &Printline($matrice,$variation,$so_term,$coord,$sorted_score[0],$score,sprintf("%.1f", $diff1),$score_variant{$sorted_score[0]},$score_variant{$score});

      } elsif ( $diff1 == $diff2 ) {
        # Separate variant if no difference in scanning
        my %max_score_variant = ();
        push ( @{ $max_score_variant{'variant'} }, pop(@{$score_variant{$score}{'variant'}}) );
        push ( @{ $max_score_variant{'coord'} }, pop(@{$score_variant{$score}{'coord'}}) );
        push ( @{ $max_score_variant{'seq'} }, pop(@{$score_variant{$score}{'seq'}}) );

        &Printline($matrice,$variation,$so_term,$coord,$sorted_score[0],$score,sprintf("%.1f", $diff1),\%max_score_variant,$score_variant{$score});

      } else {
        &Printline($matrice,$variation,$so_term,$coord,$score,$sorted_score[-1],sprintf("%.1f", $diff2),$score_variant{$score}, $score_variant{$sorted_score[-1]} );
      }
    }

    last if ($only_biggest);
  }
}

################################################################
## Print
sub Printline {
  my ($matrice,$variation,$so_term,$coord,,$max_score,$min_score,$diff,$max_score_variant,$min_score_variant) = @_;

  my $sig = log10($matrix_info{$matrice}{'pval'}{$min_score}/$matrix_info{$matrice}{'pval'}{$max_score});
  my $sig_rel = $sig/$matrix_info{$matrice}{'sigma_max'};

  ## Get minimun offset
  my $offset = $flank_len;
  my $strand_change = 0;

  foreach (@{ ${ $max_score_variant }{'coord'} }) {
    foreach my $h_coord (split(",",$_)) {
      foreach (@{ ${ $min_score_variant }{'coord'} }) {
        foreach my $l_coord (split(",",$_)) {
          my ($h_start,$h_end_strand) = split('-',$h_coord);
          my ($l_start,$l_end_strand) = split('-',$l_coord);

          if ( abs($l_start-$h_start) < abs($offset) ) {
            my ($h_end,$h_strand) =split('_',$h_end_strand);
            my ($l_end,$l_strand) =split('_',$l_end_strand);
            $offset = $l_start - $h_start;
            if ($h_strand eq $l_strand) {
              $strand_change = 0;
            } else {
              $strand_change = 1;
            }
          }
        }
      }
    }
  }

  my $str = $matrix_list{$matrice}{'id'}."\t";
  $str .= $variation."\t".$so_term."\t".$coord."\t";
  $str .= $max_score."\t".$min_score."\t";  # weigth
  $str .= $diff."\t"; #w_diff
  $str .= $matrix_info{$matrice}{'pval'}{$max_score}."\t".$matrix_info{$matrice}{'pval'}{$min_score}."\t";  # pvalues
  $str .= $matrix_info{$matrice}{'pval'}{$min_score}/$matrix_info{$matrice}{'pval'}{$max_score}."\t";  # pvalues ratio
  $str .= sprintf("%.2e", $sig)."\t"; # sigma
  $str .= sprintf("%.2e", $sig_rel)."\t"; # sigma_relatif
  $str .= join(";",@{ ${ $max_score_variant }{'variant'} })."\t".join(";",@{ ${ $min_score_variant }{'variant'} })."\t"; # variants
  $str .= join(";",@{ ${ $max_score_variant }{'coord'} })."\t".join(";",@{ ${ $min_score_variant }{'coord'} })."\t"; # coord
  $str .= $offset."\t".$strand_change."\t";
  $str .= join(";",@{ ${ $max_score_variant }{'seq'} })."\t".join(";",@{ ${ $min_score_variant }{'seq'} })."\n"; # seq

  print $out $str;
}

################################################################
## Read arguments
sub ReadArguments {
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
        $main::verbose = shift(@arguments);
      } else {
        $main::verbose = 1;
    }

=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();

=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();

=pod

=item B<-i #>

Variation file RSAT format

=cut
    } elsif ($arg eq "-i") {
      $main::infile{input} = shift(@arguments);

=pod

=item B<-m #>

The matrix file transfac format

=cut
    } elsif ($arg eq "-m") {
      $main::infile{matrixfile} = shift(@arguments);

=pod

=item B<-bg>

Background file

=cut
    } elsif ($arg eq "-bg") {
      $main::infile{bg} = shift(@arguments);

=pod

=item B<-i #>

Input File

=cut
    } elsif ($arg eq "-i") {
      $main::infile{input} = shift(@arguments);
=pod

=item B<-mml #>

Length of the longest Matrix

=cut
    } elsif ($arg eq "-mml") {
      if (&IsNatural($arguments[0])) {
        $main::flank_len = shift(@arguments)-1;
      } else {
        &RSAT::error::FatalError("-mml argument : ",shift(@arguments)," is not natual");
      }

=pod

=item B<-top_matrix #>

Only work with the # top matrix

=cut
    } elsif ($arg eq "-top_matrix") {
      if (&IsNatural($arguments[0])) {
        $main::top_matrix = shift(@arguments);
      } else {
        &RSAT::error::FatalError("-top_matrix argument : ",shift(@arguments)," is not natual");
      }

=pod

=item B<-top_variationmatrix #>

Only work with the # top variation

=cut
    } elsif ($arg eq "-top_variation") {
      if (&IsNatural($arguments[0])) {
        $main::top_variation = shift(@arguments);
      } else {
        &RSAT::error::FatalError("-top_variation argument : ",shift(@arguments)," is not natural");
      }

=pod

=item B<-pval_limit #>

Only return desequilibre with highest pval lowest than pval_limit

=cut
    } elsif ($arg eq "-pval_limit") {
      if (&RSAT::util::IsReal($arguments[0])) {
        $main::pval_limit = shift(@arguments);
      } else {
        &RSAT::error::FatalError("-pval_limit argument : ",shift(@arguments)," is not natural");
      }

=pod

=item B<-html #>

Convert the tab-delimited file into an HTML file, which facilitates the inspection of the results with a Web browser.
The HTML file has the same name as the output file, but the extension (.tab, .txt) is replaced by the .html extension

=cut
    } elsif ($arg eq "-html") {
      $main::html = 1;

=pod

=item B<-calc_distrib>

Calcul and save distribution of matrices

=cut
    } elsif ($arg eq "-calc_distrib") {
      $main::calc_distrib = 1;


=pod

=item B<-distrib_dir #>

Directory of the distribution file 

=cut
    } elsif ($arg eq "-distrib_dir") {
      $main::distrib_dir = shift(@arguments);

=pod

=item B<-distrib_list #>

Name of the file contening the list of matrix distrib file name

/!\ This file must be in the same directory as the distrib file

=cut
    } elsif ($arg eq "-distrib_list") {
      $main::infile{'distrib_list'} = shift(@arguments);

=pod


=item B<-only_biggest>

Only return the biggest difference of score between two variant of a variation

=cut
    } elsif ($arg eq "-only_biggest") {
      $main::only_biggest = 1;

=pod


=item	B<-o outputfile>

The output file is in fasta format.

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
    } elsif ($arg eq "-o") {
      $outfile{output} = shift(@arguments);

=pod

=back

=cut

    } else {
      &FatalError(join("\t", "Invalid option", $arg));
    }
  }
}

################################################################
## Verbose message
sub Verbose {
  print $out "; variation-scan ";

  &PrintArguments($out);

  printf $out "; %-22s\t%s\n", "Program version", $program_version;
  if (%main::infile) {
    print $out "; Input files\n";
    while (my ($key,$value) = each %main::infile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }

  if (%main::outfile) {
    print $out "; Output files\n";
    while (my ($key,$value) = each %main::outfile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }
}
