#!/usr/bin/perl -w
############################################################
#
# $Id: matrix-scan,v 1.61 2007/03/08 15:09:02 jvanheld Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################
## TO DO: add an option to sort hits either by position or by score
## TO DO: add a pseudo-weight to the bg model (for the time being, it only affects the matrix)
## TO DO: improve the rank output: calcualte a rank per sequence + a total rank + a rank per matrix+sequence

## use strict;
BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require "RSA.seq.lib";

use RSAT::feature;
use RSAT::matrix;
use RSAT::MatrixReader;
use RSAT::MarkovModel;
use File::Spec;

=pod

=head1 NAME

matrix-scan

=head1 DESCRIPTION

Scan sequences with one or several position-specific scoring matrices
(PSSM) to identify instances of the corresponding motifs (putative
sites). This program supports a variety of background models
(Bernoulli, Markov chains of any order).

=head1 AUTHORS

=item Jacques van Helden jvanheld@scmbb.ulb.ac.be

=item Jean Valery Turatsinze jturatsi@scmbb.ulb.ac.be

=item Morgane Thomas-Chollier <mthomas@dbm.ulb.ac.be>

=head1 CATEGORY

=over

=item sequences

=item pattern matching

=item PSSM

=back

=head1 USAGE

matrix-scan -m matrixfile [-i inputfile] [-o outputfile] [-v]
    [-bgfile backgroundfile|-bgorder #]

=head1 INPUT FORMATS

=over

=head2 Sequence file

All the formats supported in RSAT can be used as input (default: fasta).  


=head2 Matrix file

The matrix format is specified with the option -matrix_format.  Supported :
tab,cb,consensus,gibbs,meme,assembly. Default : tab.

For a description of these format, see I<convert-matrix -h>

=back

=head1 OUTPUT FORMAT

The output is a tab-delimited file, with one row per match. This file
can directly be used as input for the program I<feature-map>.


=head1 SCORING SCHEME

The program scans the input sequences with a position-specific scoring
matrix (PSSM) by selecting, at each position, a sequence segment (S)
of the same length as the matrix, and assigning a score to this
segment.

The secgment score (weight) is calculated according to the theory
developed by Jerry Hertz and Gary Stormo, but with the capability to
use Markov chain-based background models, as prposed by Thijs et
al. (2001).


The weight of a sequence segment (Ws) is calculated as the log-ratio
between two probabilities:

=item I<Ws = log[P(S|M)/P(S|B)]>

where

=over

=item I<proba_M = P(S|M)>: 

The probability to generate the sequence segment given the matrix.

=item I<proba_B = P(S|B)>: 

The probability to generate the sequence segment given the background
model.

=back

By default, the program uses natural logarithms, but the option -base
allows to specify any alternative base (e.g. 2 to obtain bit units);


=head1 BACKGROUND MODELS

=over

An essential parameter of any pattern detection approach is the choice
of an appropriate background model. This model is used to estimate the
probability for each site to occur by chance, rather than as an
instance of the motif.

The program matrix-scan supports Markov models of arbitrary order as
background models. A Markov model of order m means that the
probability of each residue depends on the m preceding residues in the
sequence. Note that a Markov model of order 0 corresponds to a
Bernoulli model, since eahc residue is independent from the preceding
ones.

A variety of options for specifying the background model.

=over

=item I<-bgfile>

This option allows to enter the background model from a background
model file. Background model files are tab-delimited files containing
the specification of oligonucleotide frequencies. A Markov model of
order m=k-1 is automatically obtained from the frequencies of
oligonucleotides of length k. There is thus no need to use the option
-markov when the background model is secified with a bg file.

The RSAT data folder contains pre-calibrated background model files
for all the supported organisms.

$RSAT/data/genomes/My_organism/oligo-frequencies/

=item I<-bginput>

The backgound model is calculated from the whole set of input
sequences. This option requires to specify the order of the background
model with the option -markov.

=item I<-window>

The background model is calculated locally at each step of the scan,
by computing transition frequencies from a sliding window centred
around the considered segment. The model is thus updated at each
scanned position. This model is called "adaptive". Note that the
sliding window must be large enough to train the local Markov
model. The required sequence length increases exponentially with the
Markov order. This option is thus usually suitable for short order
models only (-markov 0 to 1).

=back


=back

=head1 REFERENCES

The probabilities use in this program were derived from the following
papers.

=over

=item Aerts, S., Thijs, G., Coessens, B., Staes, M., Moreau, Y. & De
Moor, B. (2003).

Toucan: deciphering the cis-regulatory logic of coregulated
genes. Nucleic Acids Res 31, 1753-64.

=item Bailey, T. L. & Gribskov, M. (1998).

Combining evidence using p-values: application to sequence homology
searches. Bioinformatics 14, 48-54.

=item Hertz, G.Z., G.W. Hartzell, 3rd, and G.D. Stormo (1990). 

Identification of consensus patterns in unaligned DNA sequences known
to be functionally related. Comput Appl Biosci, 6(2): p. 81-92.

=item Hertz, G.Z. and G.D. Stormo (1999).

Identifying DNA and protein patterns with statistically significant
alignments of multiple sequences. Bioinformatics, 15(7-8): p. 563-77.

=item Staden (1989).

Methods for calculating the probabilities of finding patterns in
sequences. Comput Appl Biosci 5, 89-96.


=item Thijs, G., Lescot, M., Marchal, K., Rombauts, S., De Moor,
B., Rouze, P. & Moreau, Y. (2001).

A higher-order background model improves the detection of promoter
regulatory elements by Gibbs sampling. Bioinformatics 17, 1113-22.

=back

=cut


################################################################
## Main package
package main;
{

  ################################################################
  #### initialise parameters
  local $start_time = &AlphaDate();
  local $decimals=2;
  local $base = exp(1);
  local $sig_base = log(10);
  local %pval = (); ## This variable is defined as local to avoid passing the hash table for each match

  %main::infile = ();
  %main::outfile = ();

  @main::matrix_files = ();
  @matrices = ();

  $consensus_name = "";		# Use consensus as matrix name
  $markov = -1;	## To make the distinction with 0, which is a valid value for the markov order
  $window = -1; 
  $bg_method = "";
  $null = "NA";
  $infinite = "999"; ## String to print for infinite values (e.g. when the eval < e-300, it i rounded to 0, thus the significance is infinite)

  $bg_in_format = "oligo-analysis";
  $bg_out_format = "tab";
  local $sequence_number = 0;
  $sum_seq_len = 0;
  #    $n_containing_regions = 0;
  $n_residues = 0;

#  $base=exp(1);		## Base for the logarithms
  local $both_strands = 0;
  local $sum_seq_len = 0;
  local $origin = 0;
  local $pseudo_counts = 1;
  local $equi_pseudo = 0;
  local $matrix_format = "tab";
  local $seq_format = "fasta";
  local $verbose = 0;
  local $sort_distrib = 0;
  local $batch = 0;
  local $cluster = 0;
  #    local $in = STDIN;
  #    local $out = STDOUT;
    
  ## Threshold parameters
  local %lth = ();		# lower threshold values
  local %uth = ();		# upper threshold values
  @supported_thresholds = qw ( 
			      score
			      normw
			      pval
			      ln_pval
			      sig
			      proba_m
			      proba_b
			      rank
			      occ
			      occ_cum
			      inv_cum
			      exp_occ
			      occ_pval
			      occ_eval
			      occ_sig
			      occ_sig_rank
			     );
  $supported_thresholds = join ",", @supported_thresholds;
  %supported_threshold = ();
  foreach my $thr (@supported_thresholds) {
    $supported_threshold{$thr} = 1;
  }

  ## Treatment of N characters
  local %supported_n_treatment = (skip=>1, score=>1);
  local $supported_n_treatment = join ",", keys %supported_n_treatment;
  local $n_treatment = "skip";

  ## Return fields
  local %supported_return_fields = (
			      sites=>1,	## location of the detectes sites
			      pval=>1,	## site-wie P-value
			      rank=>1,	## site-wise ranking
			      normw=>1, ## Normalized weight

			      limits=>1, ## Sequence limits (for drawing feature maps)
			      seq_scores=>1, ## sequence-wise scores

			      distrib=>1, ## Dataset-wise distribution of scores
			      occ_proba=>1, ## Probability of the number of occurrences o predicted sites

			      matrix=>1,	## count matrices
			      freq_matrix=>1,	## Frequency matrices
			      weight_matrix=>1, ## Weight matrices

			      bg_model=>1, ## background model
			     );
  $supported_return_fields = join (",", sort(keys( %supported_return_fields)));
  local %return_fields = ();		## Fields to return
  local %calc_fields = ();		## Fields to calculate
  
  local %sequence_scores = ();
  local %matches_per_seq = ();

  local %score_distrib = ();
  local %cum_sum = ();
#  local %score_distrib_cum = ();

  ## Parameters for the &doit() command
  local $dry = 0;
  local $die_on_error = 1;
  local $job_prefix = "matrix-scan";
  local $batchmode = 0;
  
  &ReadArguments();
    
  ################################################################
  #### check argument values
  &RSAT::error::FatalError("You must specify the method for background estimation (an option among -bgfile, -bginput, -window)") unless ($bg_method);


  #################################################################
  ## Batch option
  $batch=1 if ($cluster != 0);
  
  if ($batch) {
  		local @temp_fasta_files;
  		local @temp_output_files;
  		
		### open output stream
 		$main::out = &OpenOutputFile($main::outfile{output});
  		
  		&Verbose() if ($main::verbose);
  		&runInBatch();
  
  		close $main::out;
  	
    	## Clean some temporary files
    	if ($main::outfile{output_raw}) {
    		my $clean_partial_cmd = "rm -f $main::outfile{output_raw}";
    		&doit($clean_partial_cmd, $dry, $die_on_error, $verbose, $batchmode, $job_prefix);
    	}
    	
    	## Remove sequence files    
    	if (scalar(@temp_fasta_files) > 0) {
    		my $clean_partial_cmd = "rm -f ";
    		$clean_partial_cmd .= join (" ", @temp_fasta_files);
    		&doit($clean_partial_cmd, $dry, $die_on_error, $verbose, $batchmode, $job_prefix);
    	}
    	## Remove individual result files    
    	if (scalar(@temp_output_files) > 0) {
    		my $clean_partial_cmd = "rm -f ";
    		$clean_partial_cmd .= join (" ", @temp_output_files);
    		&doit($clean_partial_cmd, $dry, $die_on_error, $verbose, $batchmode, $job_prefix);
    	}
    	
  		exit(0);
  }
  

  ## normw is incompatible with sliding windows
  if (($return_fields{normw}) && ($bg_method eq "window")) {
    &RSAT::message::Warning("The normw computation cannot be done with a sliding window. Normw will not be returned.");
    undef($return_fields{normw});
  }

  ## weight_matrix is incompatible with orders > 0
  if (($return_fields{weight_matrix}) && ($markov > 0)) {
    &RSAT::message::Warning("The concept of weight matrix is incompatible with higher order Markov chains. Weight matrix will not be returned.");
    undef($return_fields{weight_matrix});
  }
 

  ## Calculate only once the denominator for the logarithms
  local $log_base = log($base);

  ## Return fields
  if (scalar(keys(%return_fields)) < 1) {
    $return_fields{sites} = 1;
    $return_fields{pval} = 1;
  } elsif ($return_fields{pval}) {
    ## It makes no sense to return pval without sites
    $return_fields{sites} = 1;
  }

  if ((defined($uth{normw})) || (defined($lth{normw}))) {
    $return_fields{normw} = 1;
  }
  if ((defined($uth{pval})) || (defined($lth{pval}))) {
    $return_fields{pval} = 1;
  }
  if ((defined($uth{rank})) || (defined($lth{rank}))) {
    $return_fields{rank} = 1;
  }


   
  ## Background distribution is required for the distrib probabilities
  if ($return_fields{occ_proba}) {
    $return_fields{distrib} = 1;
    $calc_fields{pval} = 1;

#     &RSAT::error::FatalError("The option -return score_distrib requires a background score distribution (-bg_distrib)")
#       unless ($infile{bg_distrib});
	################################################################
    ## Load the background score distribution
    if ($infile{bg_distrib}) {
      my ($in, $input_dir) = &OpenInputFile($infile{bg_distrib});
      my $l = 0;
      &RSAT::message::TimeWarn("Loading background score distribution from file", $infile{bg_distrib})
	if ($main::verbose >= 2);
      while (<$in>) {
	$l++;
	next if (/^--/);       	# skip comment lines
	next if (/^;/);		# skip comment lines
	next if (/^#/);		# skip header lines
	next unless (/\S/);	# skip empty lines
	chomp;
	my ($matrix_name, $score, $occ, $occ_cum, $inv_cum, $freq_inv_cum) = split "\t";
	$exp_score_distrib->{$matrix_name}->{$score}->{occ_prior} = $freq_inv_cum;
#	&RSAT::message::Debug("Loading bg distrib", $matrix_name, $score,
#			      $exp_score_distrib->{$matrix_name}->{$score}->{occ_prior}) 
#	  if ($main::verbose >= 0);
      }
      close $in;
    }
  }

  ## Fields to calculate
  if (($return_fields{sites}) 
      || ($return_fields{distrib}),
     ) {
    $calc_fields{sites} = 1;
  }
  if ($return_fields{seq_scores}) {
    $calc_fields{sites} = 1;
    $calc_fields{pval} = 1;
  }
  if ($return_fields{distrib}) {
        $calc_fields{pval} = 1;
  }


  ## Ensure that all the fields to return are calculated
  foreach my $field (keys(%return_fields)) {
    $calc_fields{$field} = 1;
  }

  ################################################################
  ## Load the matrix list if specified
  if ($infile{matrix_list}) {
    my ($mlist, $input_dir) = &OpenInputFile($main::infile{matrix_list});
    while (<$mlist>) {
      next if (/'^;'/);		# skip comment lines
      next if (/'^#'/);		# skip header lines
      next if (/'^--'/);	# skip mysql-type comment lines
      next unless (/\S/);	# skip empty lines

      my @fields = split /\s+/;
      my $matrix_file = $fields[0];
      push @matrix_files, $matrix_file;
    }
    close $mlist;
    &RSAT::message::Info("Read matrix list from file", $infile{matrix_list}, scalar(@matrix_files), "matrices") if ($main::verbose >= 2);
  }

  ################################################################
  ## Check that there is at least one input matrix
  unless (scalar(@matrix_files >= 1)) {
    &RSAT::error::FatalError("You must specify at least one matrix file.");
  }


  ################################################################
  ### open output stream
  $main::out = &OpenOutputFile($main::outfile{output});

  ################################################################
  ## Background model specification
  local $bg_model = new RSAT::MarkovModel();

  if ($main::both_strands) {
    $bg_model->set_attribute("strand", "insensitive");
  } else {
    $bg_model->set_attribute("strand", "sensitive");
  }
  $bg_model->set_attribute("n_treatment", $n_treatment);

  if ($infile{bg}) {
    ## Read background model from a file
    &RSAT::message::TimeWarn(join("\t", "Reading background model from file", $infile{bg})) 
      if ($main::verbose >= 2);
    $bg_model->load_from_file($infile{bg}, $bg_in_format);
    $bg_model->check_missing_transitions();

    #      &RSAT::message::Debug($bg_model->to_string($bg_out_format)) if ($main::verbose >= 0);
  } elsif ($main::markov >= 0) {
    $bg_model->set_attribute("order", $main::markov);
    if (($main::window >= 0) && ($main::window < $main::markov+1)) {
      &RSAT::error::FatalError(join("", 
				    "Window size (",
				    $main::window,
				    ") must be larger than Markov order + 1 (",
				    $main::markov."+1)."));
    }

    ## TO DO: read the sequences once to determine prior frequencies, in
    ## order to set the pseudo-weight distribution

    ################################################################
    ## If the model is taken from the whole set of input sequences, read them
    ## first without scanning, just to calculate the model
    if ($bg_method eq "input") {
      unless ($main::infile{input}) {
	&RSAT::error::FatalError("The option -bg_input requires to specify an input file (STDIN is not supported with this option.");
      }
      my ($in, $input_dir) = &OpenInputFile($main::infile{input});
      while ((($current_seq, $seq_id) = &ReadNextSequence($in, $seq_format, $input_dir, "",$mask)) &&
	     (($current_seq ne "") || ($seq_id ne ""))) {

	## Sequence length
	$current_seq = lc($current_seq);
	$bg_model->calc_from_seq($current_seq, add=>1);
      }
      close $in;
      $bg_model->check_missing_transitions();
      $bg_model->normalize_transition_frequencies();
    }
  } else {
    &RSAT::error::FatalError("You should either define the Markov order (-markov) or specify a file (-bgfile) for the background model.");
  }

  ################################################################
  ## Read the position-specific scoring matrices
  ################################################################
  ## Set prior matrix frequencies from the bg model and calculate
  ## derived statistics
  my %prior = $bg_model->get_attribute("suffix_proba");
  &RSAT::message::TimeWarn(join("\t", "PRIOR", join(" ", %prior))) if ($main::verbose >= 3);
  foreach my $matrix_file (@matrix_files) {
    my @new_matrices = &RSAT::MatrixReader::readFromFile($matrix_file, $matrix_format);

    foreach my $m (0..$#new_matrices) {
      my $matrix = $new_matrices[$m];
      $matrix->force_attribute("decimals", $decimals);
      $matrix->set_attribute("scored", 0); ## Number of sequence segments for which the matrix calculated a score
      $matrix->set_attribute("matches", 0); ## Initialize the match counter
      $matrix->set_parameter("pseudo", $pseudo_counts);
      #	$matrix->push_attribute("parameters", "pseudo");
      $matrix->set_attribute("equi_pseudo", $main::equi_pseudo);
      $matrix->set_attribute("file", $matrix_file);
      $matrix->set_attribute("n_treatment", $n_treatment);
      $matrix->index_alphabet();

      ## Use the matrix consensus as name
      if ($consensus_name) {
	$matrix->calcConsensus();
	my $consensus = $matrix->get_attribute("consensus.IUPAC");
	if ($consensus) {
	  &RSAT::message::Warning("Using consensus as name", $consensus) if ($main::verbose >= 3);
	  $matrix->force_attribute("name", $consensus);
	}
      } else {
	my ($matrix_name) = &RSAT::util::ShortFileName($matrix_file);
	$matrix_name =~ s/\.\S+$//; ## suppress the extension from the file name
	if (scalar(@new_matrices) > 1) {
	  $matrix_name .= ".".($m+1);
	}
	$matrix->force_attribute("name", $matrix_name);
      }

      ## Check that the matrix width is smaller than markov order + 1
      my $matrix_width = $matrix->ncol();
      my $markov_order = $bg_model->get_attribute("order");
      if ($matrix_width < $markov_order + 1) {
	&RSAT::error::FatalError(join (" ", 
				       "Markov order (".$markov_order.")",
				       "is too large for matrix",
				       $matrix->get_attribute("name"),
				       "of width ".$matrix_width."."));
      }
	
      ## Calculate min and max values for P(S|M)
      $matrix->proba_range();
	
      ## Set the matrix prior
      $matrix->setPrior(%prior);
      &RSAT::message::TimeWarn(join("\t", "Setting matrix priors for matrix", $matrix->get_attribute("name"), 
				    %prior, join(" ", $matrix->getPrior()))) if ($main::verbose >= 3);
      ## Calculate min and max weight values
      my ($Wmin, $Wmax, $Wrange) = $matrix->weight_range();
      &RSAT::message::TimeWarn(join("\t", "Calculated weight range for matrix", 
				    $matrix->get_attribute("name"), 
				    $Wmin, $Wmax, $Wrange,
				   )) if ($main::verbose >= 3);
	
      push @matrices, $matrix;
	
      &RSAT::message::TimeWarn("Read matrix", 
			       scalar(@matrices), 
			       $matrix->get_attribute("name"),
			       $matrix->get_attribute("file")
			      ) if ($main::verbose >= 3);
    }
  }

  ################################################################
  ## Calculate th pval distribution
  if ($calc_fields{pval}) {
    foreach my $matrix (@matrices) {
      %{$pval{$matrix}} = $matrix->getTheorScoreDistrib("weights", "inv_cum");
    }
  }

  ################################################################
  #### print verbose
  &Verbose() if ($main::verbose);

  ## Print header
  if ($return_fields{sites}) {
    print $out "#", join ("\t", 
			  "seq_id",
			  "ft_type",
			  "ft_name",
			  "strand",
			  "start",
			  "end",
			  "sequence",
			  "weight",
			  "proba_M",
			  "proba_B",
			 );
    if ($return_fields{pval}) {
      print $out "\t", "Pval";
      print $out "\t", "ln_Pval";
      print $out "\t", "sig";
    }
    print $out "\tnormw" if ($return_fields{normw});
    print $out "\trank" if ($return_fields{rank});
    print $out "\n";
  }

  ################################################################
  ##### Scan the sequences
  &RSAT::message::TimeWarn("Scaning sequences with", scalar(@matrices), "matrices") if ($main::verbose >= 2);

  my ($in, $input_dir) = &OpenInputFile($main::infile{input});
  local($current_seq, $seq_id);
  while ((($current_seq, $seq_id) = &ReadNextSequence($in, $seq_format, $input_dir, "",$mask)) &&
	 (($current_seq ne "") || ($seq_id ne ""))) {

    ## If the rank is required, it is calculated for each input sequence independently
  #  local @matches = (); ## Only used whe the rank of the site is required
 #   local %matches_per_matrix = ();

    ## Initialize sequence scores
    $sequence_scores->{$seq_id}->{length} = length($current_seq);
    $sequence_scores->{$seq_id}->{matches} = 0;
    $sequence_scores->{$seq_id}->{weight_sum} = 0;
    $sequence_scores->{$seq_id}->{sig_sum} = 0;

    ## Count the number of N residues and increment the corresponding counter
    my $n_seq = $current_seq;
    $n_seq =~ s/[^N]//gi;
    $n_residues += length($n_seq);

    ## Sequence length
    $current_seq = lc($current_seq);
    $sequence_number++;
    my $seq_len = length($current_seq);
    $sum_seq_len += $seq_len;

    ## Calculate the origin
    $orig_pos = 0;
    if (($main::origin <  0) || ($main::origin eq "-0")) {
      $orig_pos = $seq_len + $main::origin + 1; 
    } else {
      $orig_pos = $main::origin;
    }

    ################################################################
    ## Report sequence limits
    &PrintSequenceLimits($seq_id, $seq_len, $orig_pos) if ($return_fields{limits});

    ################################################################
    ## Calculate background model from the current sequence
    my $window_offset = 0;
    if (($main::markov >= 0) && ($bg_method ne "input")) {
      if ($main::window >= $main::markov + 1) {
	if ($main::window > $seq_len) {
	  &RSAT::message::Warning(join("\t",
				       $seq_id,
				       "sequence length",
				       $seq_len,
				       "smaller than sliding window size",
				       $main::window,
				      )) if ($main::verbose >= 2);
	  $bg_model->calc_from_seq($current_seq);
	} else {
	  ## initialize the model with the first window
	  $bg_model->calc_from_seq(substr($current_seq,0,$main::window));
	}
      } else {
	## calculate the model from the entire current sequence
	$bg_model->calc_from_seq($current_seq);
      }
    }

    ################################################################
    ## Detect sites
    &RSAT::message::TimeWarn("Scanning sequence with ".scalar(@matrices)." PSSM", $sequence_number,  $seq_id,"len=".$seq_len, "orig=".$orig_pos,  $seq_id)
      if ($main::verbose >= 3);

    &RSAT::message::psWarn("Scanning sequence with ".scalar(@matrices)." PSSM", $sequence_number,  $seq_id,"len=".$seq_len, "orig=".$orig_pos,  $seq_id) if (($main::verbose >= 3) && (($sequence_number % 50) == 0));
    if ($calc_fields{sites}) {
      #	  $n_containing_region = 0;
      for my $pos (1..$seq_len) {

	## Update background model if required
	if (($main::window > 0) &&
	    ($pos > $main::window/2) &&
	    ($pos + $main::window <= $seq_len)) {
	  my $added_word = substr($current_seq, $window_offset + $main::window - $main::markov, $markov+1);
	  my $deleted_word = substr($current_seq, $window_offset, $markov+1);
	  $bg_model->two_words_update($added_word, $deleted_word, $window_offset);
	  $window_offset++;
	}

	## Detect sites
	foreach my $matrix (@matrices) {
	  my $ncol = $matrix->{ncol};
	  next if ($seq_len - $pos +1 < $ncol);
	  my $segment = substr($current_seq, $pos-1, $ncol);

	  ## Skip N-containing segments
	  if (($n_treatment eq "skip") &&
	      ($segment =~ /n/i)) {
	    unless ($n_containing_region) {
	      ## Start of an N-containing region
	      &RSAT::message::Info(join("\t", "N-containing segment start at position", $pos))
		if ($main::verbose >= 4);
	    }
	    $n_containing_region = 1;
	    #		$n_containing_regions ++;
	    next;
	  }

	  ## Report the end of the N-containing region
	  if (($n_treatment eq "skip") && ($n_containing_region)) {
	    &RSAT::message::Info(join("\t", "N-containing segment ended at position", $pos -1))
	      if ($main::verbose >= 4);
	    $n_containing_region = 0;
	  }

	  ## TO DO: test if this piece of code can be
	  ## optimized by passing the pointer rather than the
	  ## whole matrix
	  &score_segment($segment, $matrix, $seq_id, $pos, "D");
	  if ($main::both_strands) {
	    &score_segment( &ReverseComplement($segment),$matrix, $seq_id, $pos, "R");
	  }
	  ;
	}
      }
    }

    if (($return_fields{sites})  && (defined(@{$matches_per_seq{$seq_id}}))) {
		&RSAT::message::TimeWarn( "Returning individual matches for sequence", $seq_id )
		if ($main::verbose >= 2);
      ################################################################
      ## Sort the matches
      my @ranked_matches = @{$matches_per_seq{$seq_id}};
      if (scalar(@ranked_matches) <= 0) {
	&RSAT::message::Info("No match in sequence",
			     $seq_id,
			    ) if ($main::verbose >= 3);
	next;
      }

     
      if ($calc_fields{rank}) {
      	 &RSAT::message::TimeWarn("Sorting matches for sequence", $seq_id) if ($main::verbose >= 3);
	if ($calc_fields{pval}) {
	  ## Sort matches by significance
	  @ranked_matches =
	    sort {$b->get_attribute('sig') <=> $a->get_attribute('sig')} 
	      @ranked_matches;
	} else {
	  ## Sort matches by weight score
	  @ranked_matches =
	    sort {$b->get_attribute('score') <=> $a->get_attribute('score')}
	      @ranked_matches;
	}
      }
      
      ################################################################
      ## Return the matches
      my $rank = 0;
      foreach my $match (@ranked_matches) {
	$rank++;
	$match->force_attribute('rank', $rank);
	next if ((defined($lth{rank})) && ($rank < $lth{rank}));
	&print_match($match);
	last if ((defined($uth{rank})) && ($rank >= $uth{rank}));
      }
    }
  }



  ################################################################
  ## Print sequence-zise statistics
  if ($return_fields{seq_scores}) {
    &RSAT::message::TimeWarn("Printing scores per sequence") if ($main::verbose >= 0);
    print $out join("\t", "seq_id", "length", "scored", "matches", "w_sum", "sig_sum", "sig_rank"), "\n";
    my @sorted_sequences = sort (keys %{$sequence_scores});
      @sorted_sequences = sort {$sequence_scores->{$b}->{sig_sum} <=> $sequence_scores->{$a}->{sig_sum}} @sorted_sequences;
    my $rank = 0;
    foreach my $seq_id (@sorted_sequences) {
      $rank++;
      print $out join ("\t",
		       $seq_id,
		       $sequence_scores->{$seq_id}->{length},
		       $sequence_scores->{$seq_id}->{scored},
		       $sequence_scores->{$seq_id}->{matches},
		       $sequence_scores->{$seq_id}->{weight_sum},
		       $sequence_scores->{$seq_id}->{sig_sum},
		       $rank,
		       ), "\n";
    }
  }


  close $in if ($main::infile{input});

  ################################################################
  ## Print additional information

  ## Calculate maximal length of matrix name for the headers
  my $max_name_len = 0;
  foreach my $matrix (@matrices) {
    my $name = $matrix->get_attribute("name");
    $max_name_len = &max($max_name_len, length($name));
  }

  ################################################################
  ## Report the PSSM Matrices
  &RSAT::message::TimeWarn ("Reporting matrix information") if ($main::verbose >= 2);

  ## Print summary statistics of each matrix
  if ($main::verbose >= 1) {
    print $main::out ";\n; Matrices\n";
    print $out join ("\t", ";", 
		     sprintf("%-${max_name_len}s", "name"),
		     "ncol",
		     "nrow",
		     "pseudo",
		     "Pmin",
		     "Pmax",
		     "Wmin",
		     "Wmax",
		     "Wrange",
		     "prior",
		    ), "\n";

    foreach my $matrix (@matrices) {
      print $out join ("\t", ";", 
		       $matrix->get_attribute("name"),
		       $matrix->get_attribute("ncol"),
		       $matrix->get_attribute("nrow"),
		       $matrix->get_attribute("pseudo"),
		       sprintf("%5.2g", $matrix->get_attribute("min(P(S|M))")),
		       sprintf("%5.2g", $matrix->get_attribute("max(P(S|M))")),
		       sprintf("%.3f", $matrix->get_attribute("Wmin")),
		       sprintf("%.3f", $matrix->get_attribute("Wmax")),
		       sprintf("%.3f", $matrix->get_attribute("Wrange")),
		      );
      my %prior = $matrix->getPrior();
      print $out "\t";
      foreach my $letter (sort keys %prior) {
	printf $out "%s:%.3f ", $letter, $prior{$letter};
      }
      print $out "\n";
    }
  }

  ## Return count matrices
  my $m = 0;
  if ($return_fields{matrix}) {
    foreach my $matrix (@matrices) {
      $m++; print $out "//\n" if ($m >= 1);
      print $out ";\n; Count matrix\t", $matrix->get_attribute("name"), "\n";
      print $out $matrix->toString(col_width=>(7), decimals=>0, type=>"counts",format=>"tab", comment_string=>";");
    }
  }

  ## Return frequency matrices
  if ($return_fields{freq_matrix}) {
    foreach my $matrix (@matrices) {
      $m++; print $out "//\n" if ($m >= 1);
      print $out ";\n; Frequency matrix\t", $matrix->get_attribute("name"), "\n";
      print $out $matrix->toString(col_width=>(7), decimals=>3, type=>"frequencies",format=>"tab", comment_string=>";");
    }
  }

  ## Return weight matrices
  if ($return_fields{weight_matrix}) {
    foreach my $matrix (@matrices) {
      $m++; print $out "//\n" if ($m >= 1);
      print $out ";\n; Weight matrix\t", $matrix->get_attribute("name"), "\n";
      print $out $matrix->toString(col_width=>(7), decimals=>3, type=>"weights", format=>"tab", comment_string=>";");
    }
  }

  ## Report background model
  if ($return_fields{bg_model}) {
    print $out ";\n; Background model\n";
    print $out $bg_model->to_string($bg_out_format, comment_string=>"; ");
  }

  ################################################################
  ## Report score distribution
  if ($return_fields{distrib}) {

    ################################################################
    ##  Calculate cumulative frequencies
    &RSAT::message::TimeWarn("Calculating cumulative frequencies") if ($main::verbose >= 2);
    foreach my $matrix (@matrices) {
      my $matrix_name = $matrix->get_attribute("name");
      $cum_sum{$matrix_name} = 0;

      my @sorted_scores = sort {$a <=> $b} keys %{$score_distrib->{$matrix_name}};
      &RSAT::message::Info("score range", $matrix_name, $sorted_scores[0], $sorted_scores[$#sorted_scores], scalar(@sorted_scores)) if ((scalar(@sorted_scores) >= 1) && ($main::verbose >= 3));

      foreach my $score (@sorted_scores) {
	unless (defined($score_distrib->{$matrix_name}->{$score}->{occ})) {
	  $score_distrib->{$matrix_name}->{$score}->{occ} = 0;
	}
	$cum_sum{$matrix_name} += $score_distrib->{$matrix_name}->{$score}->{occ};
	$score_distrib->{$matrix_name}->{$score}->{occ_cum} = $cum_sum{$matrix_name};
	#	  &RSAT::message::Debug($matrix, "score", $score, "cum_sum", $cum_sum{$matrix_name}) if ($main::verbose >= 10);
      }
    }

    ################################################################
    ## Calculate inverse cumulative frequencies
    &RSAT::message::TimeWarn("Calculating cumulative frequencies") if ($main::verbose >= 2);
    foreach my $matrix (@matrices) {
      my $matrix_name = $matrix->get_attribute("name");
      my @sorted_scores = sort {$a <=> $b} keys %{$score_distrib->{$matrix_name}};
      &RSAT::message::Info("score range", $matrix_name, $sorted_scores[0], $sorted_scores[$#sorted_scores], scalar(@sorted_scores)) if ((scalar(@sorted_scores) >= 1) && ($main::verbose >= 3));
      foreach my $score (@sorted_scores) {
	my $occ = $score_distrib->{$matrix_name}->{$score}->{occ};
	my $occ_cum = $score_distrib->{$matrix_name}->{$score}->{occ_cum};
	$score_distrib->{$matrix_name}->{$score}->{inv_cum} = $cum_sum{$matrix_name} - $occ_cum + $occ;
	$score_distrib->{$matrix_name}->{$score}->{score} = $score; ## This is just a trick to filter the distrib on score thresholds
      }
    }

    ################################################################
    ## Check distribution thresholds on score. This can only be done
    ## after having computed the cumulative and inverse umulative
    ## frequencies
    &check_distrib_thresholds('score');

    ################################################################
    ## Check thresholds on occurrences
    &check_distrib_thresholds('occ');
    &check_distrib_thresholds('occ_cum');
    &check_distrib_thresholds('inv_cum');

    ################################################################
    ## Calculate the significance of the score distribution
    my $nb_of_tests = 0;
    if ($return_fields{occ_proba}) {

      ## Calculate expected number of occurrences with a score >= x 
      &RSAT::message::TimeWarn("Calculating expected inverse cumulative distribution.") 
	if ($main::verbose >= 2);
      foreach my $matrix (@matrices) {
	my $matrix_name = $matrix->get_attribute("name");
	my $n = $matrix->{scored};
	my @sorted_scores = sort {$a <=> $b} keys %{$score_distrib->{$matrix_name}};
	&RSAT::message::Info("score range", $matrix_name, $sorted_scores[0], $sorted_scores[$#sorted_scores], scalar(@sorted_scores)) if ((scalar(@sorted_scores) >= 1) && ($main::verbose >= 3));
	foreach my $score (@sorted_scores) {
	  my $x = $score_distrib->{$matrix_name}->{$score}->{inv_cum} || 0;

	  my $prior = $null;
	  if ($infile{bg_distrib}) {
	    if (defined($exp_score_distrib->{$matrix_name}->{$score}->{occ_prior})) {
	      ## Take the prior from the backround file
	      $prior  = $exp_score_distrib->{$matrix_name}->{$score}->{occ_prior};
	      &RSAT::message::Debug("Estimating prior from bg_distrib file",
				    $matrix_name, $score, $prior) if ($main::verbose >= 5);
	    } else {
	      &RSAT::message::Warning("The  bg distrib file does not contain prior probability for matrix",
				    $matrix_name, "with score", $score) if ($main::verbose >= 0);
	    }
	  } else {
	    $prior = ${$main::pval{$matrix}}{$score};
	  }
	  $score_distrib->{$matrix_name}->{$score}->{occ_prior} = $prior;
	  if ($prior eq $null) {
	    $score_distrib->{$matrix_name}->{$score}->{exp_occ} = $null;
	  } else {
	    $score_distrib->{$matrix_name}->{$score}->{exp_occ} = $prior * $n;
	  }
	}
      }
      &check_distrib_thresholds('exp_occ');

      ## Calculate significance of the number of motif occurrences
      &RSAT::message::TimeWarn("Calculating probabilities for the score distribution.") 
	if ($main::verbose >= 2);
      foreach my $matrix (@matrices) {
	my $matrix_name = $matrix->get_attribute("name");
	my $n = $matrix->{scored};
	my @sorted_scores = sort {$a <=> $b} keys %{$score_distrib->{$matrix_name}};
	&RSAT::message::Info("score range", $matrix_name, $sorted_scores[0], $sorted_scores[$#sorted_scores], scalar(@sorted_scores)) if ((scalar(@sorted_scores) >= 1) && ($main::verbose >= 3));
	foreach my $score (@sorted_scores) {
	  my $x = $score_distrib->{$matrix_name}->{$score}->{inv_cum};

	  ## Check that the background file contains the required prior
	  my $hit_p = $null;
	  if (defined($exp_score_distrib->{$matrix_name}->{$score}->{occ_prior})) {
	    $hit_p  = $exp_score_distrib->{$matrix_name}->{$score}->{occ_prior};
	  } elsif (defined(${$main::pval{$matrix}}{$score})) {
	    $hit_p = ${$main::pval{$matrix}}{$score};
	  }
	  $score_distrib->{$matrix_name}->{$score}->{occ_prior} = $hit_p;

	  if ($hit_p eq $null) {
	    &RSAT::message::Warning("No prior defined for matrix", $matrix->get_attribute("name"), 
				    "score", $score, 
				    "in background score distribution file");
	    $score_distrib->{$matrix_name}->{$score}->{exp_occ} = $null;
	    $score_distrib->{$matrix_name}->{$score}->{occ_pval} = $null;
	    $score_distrib->{$matrix_name}->{$score}->{occ_eval} = $null;
	    $score_distrib->{$matrix_name}->{$score}->{occ_sig} = $null;
	  } else {

	    ## Calcualte the binomial P-value
	    &RSAT::message::Debug("Calculating pval", $matrix_name, $score, $x, $n, $hit_p)
	      if ($main::verbose >= 5);
	    $score_distrib->{$matrix_name}->{$score}->{occ_pval} =
	      &sum_of_binomials($hit_p, ## prior probabilty
				$n,	## Number of trials
				$x,	## Min number of successes
				$n,	## Max number of successes
			       );
	    $nb_of_tests++;
	  }
#	  &RSAT::message::Debug("Calculated significance", $matrix_name, $score, $x,
#				$hit_p,
#				$score_distrib->{$matrix_name}->{$score}->{occ_pval},
#			       ) if ($main::verbose >= 10);
#	    die;
	}
      }
    }

    ################################################################
    ## Check thresholds on significance
    &check_distrib_thresholds('occ_pval');

    ################################################################
    ## Perform correction for multi-testing (calculate E-value and
    ## significance).
    &RSAT::message::TimeWarn("Calculating E-value and significance") if ($main::verbose >= 2);
    foreach my $matrix (@matrices) {
      my $matrix_name = $matrix->get_attribute("name");
      my @sorted_scores = sort {$a <=> $b} keys %{$score_distrib->{$matrix_name}};
      &RSAT::message::Info("score range", $matrix_name, $sorted_scores[0], $sorted_scores[$#sorted_scores], scalar(@sorted_scores)) if ((scalar(@sorted_scores) >= 1) && ($main::verbose >= 3));
      foreach my $score (@sorted_scores) {
	my $occ_eval = $null;
	my $occ_sig = $null;
	if (defined($score_distrib->{$matrix_name}->{$score}->{occ_pval})) {
	  my $occ_pval = $score_distrib->{$matrix_name}->{$score}->{occ_pval};
	  unless ($occ_pval eq $null) {
	    $occ_eval = $score_distrib->{$matrix_name}->{$score}->{occ_pval}*$nb_of_tests;
	    if ($occ_eval > 0) {
	      $occ_sig = -log($occ_eval)/$sig_base;
	    } else {
	      $occ_sig = $infinite;
	    }
	  }
	}
	$score_distrib->{$matrix_name}->{$score}->{occ_eval} = $occ_eval;
	$score_distrib->{$matrix_name}->{$score}->{occ_sig} = $occ_sig;
      }
    }
    &check_distrib_thresholds('occ_eval');
    &check_distrib_thresholds('occ_sig');

    &PrintScoreDistrib();
  }

  ################################################################
  ###### Finish verbose
  if ($main::verbose >= 1) {

    ## Sequence statistics
    printf $main::out "; %-21s\t%s\n", "Number of sequences scanned", $sequence_number;
    printf $main::out "; %-21s\t%s\n", "Sum of sequence lengths", $sum_seq_len;
    #	printf $main::out "; %-21s\t%s\n", "N-containing regions", $n_containing_regions if ($n_containing_regions >= 0);
    printf $main::out "; %-21s\t%s\n", "N residues", $n_residues if ($n_residues >= 0);

    ## Matching statistics
    print $main::out "; Matches per matrix\n";
    print $main::out join("\t", ";",
			  sprintf("%-${max_name_len}s", "matrix"),
			  "matches",
			  "scored",
			 ), "\n";

    my $total_scored = 0;
    my $total_matches = 0;
    foreach my $matrix (@matrices) {
      $total_matches += $matrix->get_attribute("matches");
      $total_scored += $matrix->get_attribute("scored");
      print $main::out join ("\t", ";", 
			     sprintf("%-15s", $matrix->get_attribute("name")),
			     sprintf("%d", $matrix->get_attribute("matches")),
			     sprintf("%d", $matrix->get_attribute("scored")),
			    ), "\n";
    }
    print $main::out join ("\t", ";", 
			   sprintf("%-15s", "TOTAL"),
			   $total_matches,
			   $total_scored,
			  ), "\n";
	
    my $done_time = &AlphaDate();
    print $main::out "; Job started $start_time\n";
    print $main::out "; Job done    $done_time\n";
  }
    

  ################################################################
  ###### close output stream
  close $main::out if ($main::outfile{output});
    
    
  exit(0);
}

################################################################
################### subroutine definition ######################
################################################################


################################################################
#### display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
#### display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
#### Read arguments 
sub ReadArguments {
    my $arg = "";
    
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    

    while ($arg = shift (@arguments)) {

	## Verbosity
=pod
	    

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }
	    
	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();
	    
	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Background model file
=pod

=item B<-bgfile background_file>

Background model file.

=cut
	} elsif ($arg eq "-bgfile") {
	  &RSAT::error::FatalError("Options -bgfile, -bginput and -window are mutually exclusive") if ($main::bg_method);
	  $main::bg_method = "file";
	  $main::infile{bg} = shift(@arguments);
	  &RSAT::error::FatalError("The options -markov and -bgfile are mutually exclusive.") 
	    if ($main::markov >= 0);
	  
	  ## Background calculated from the input sequence set
=pod

=item B<-bginput>

Calculate background model from the input sequence set.

=cut
	} elsif ($arg eq "-bginput") {
	  &RSAT::error::FatalError("Options -bgfile, -bginput and -window are mutually exclusive") if ($main::bg_method);
	  $main::bg_method = "input";
	  &RSAT::error::FatalError("The options -bginput and -window are mutually exclusive.") 
	    if ($main::window >= 0);
	  &RSAT::error::FatalError("The options -bginput and -bgfile are mutually exclusive.") 
		if defined($main::infile{bg});
	  
	  ## Calculate background model from the input sequence
=pod

=item B<-markov>

Order of the markov chain for the background model. 

This option is incompatible with the option -bgfile. 

=cut
	} elsif ($arg eq "-markov") {
	    $main::markov = shift(@arguments);
	    &RSAT::error::FatalError("Markov order must be a natural number.") 
		unless &RSAT::util::IsNatural($main::markov);
	    &RSAT::error::FatalError("The options -markov and -bgfile are mutually exclusive.") 
		if defined($main::infile{bg});


=pod

=item B<-window>

Size of the sliding window for the background model calculation. 

=cut
	} elsif ($arg eq "-window") {
	  &RSAT::error::FatalError("Options -bgfile, -bginput and -window are mutually exclusive") if ($main::bg_method);
	  $main::bg_method = "window";
	  $main::window = shift(@arguments);
	  &RSAT::error::FatalError("Window size must be a natural number.") 
	    unless &RSAT::util::IsNatural($main::window);
	  &RSAT::error::FatalError("The options -window and -bgfile are mutually exclusive.") 
	    if defined($main::infile{bg});
	  
	  
	    ## Matrix file
=pod

=item B<-m matrixfile>

Matrix file. 

This argument can be used iteratively to scan the sequence with
multiple matrices.

=cut
	} elsif ($arg eq "-m") {
	    push @matrix_files, shift(@arguments);
#	    $main::infile{matrix} = shift(@arguments);

	    ## Use consensus as matrix name
=pod

=item B<-consensus_name>

Use the motif (degenerate) consensus as matrix name.

=cut
	} elsif ($arg eq "-consensus_name") {
	  $main::consensus_name = 1;

	    ## Matrix file
=pod

=item B<-mlist matrix_list>

Matrix list. 

Indicate a file containing a list of matrices to be used for scanning
the region. This facilitates the scanning of a sequence with a library
of matrices (e.g. all the matrices from RegulonDB, or TRANSFAC). 

Format: the matrix list file is a text file. The first word of each
row is suppose to indicate a file name. Any further information on the
same row is ignored.

=cut
	} elsif ($arg eq "-mlist") {
	    $main::infile{matrix_list} = shift(@arguments);


	    ## Sequence format
=pod

=item B<-seq_format sequence_format>

Sequence format. 

=cut
	} elsif ($arg eq "-seq_format") {
	    $seq_format = shift(@arguments);
	    
	    ## Matrix format
=pod

=item B<-matrix_format matrix_format>

Matrix format. 

=cut
	} elsif ($arg eq "-matrix_format") {
	    $matrix_format = shift(@arguments);

	    ## Input file
=pod

=item B<-i inputfile>

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{input} = shift(@arguments);

	    ## mask
=pod

=item B<-mask upper|lower>

Mask lower or uppercases, respecively, i.e. replace selected case by N
characters.

=cut

	} elsif ($arg eq "-mask") {
	    $main::mask = shift(@arguments);
	    &CheckMask($main::mask);	    

=pod 

=item B<-n [skip|score]>

Treatment of N characters. These characters are often used in DNA
sequences to represent undefined or masked nucleotides.

=over

=item I<skip>

N-containing regions are skipped.

=item I<score>

N-containing regions are scored. The probability of an N is 1 for both
the background model and the matrix. The N residues will thus
contribute neither positively nor negatively to the weight score of
the N-containing fragment. This option can be useful to detect sites
which are at the border of N-containing regions, or in cases there are
isolated N in the sequences.

=back

=cut
	} elsif ($arg eq "-n") {
	    $main::n_treatment = shift(@arguments);
	    &RSAT::error::FatalError("Invalid value for the -n option. supported: ".$supported_n_treatment)
	      unless ($supported_n_treatment{$main::n_treatment});



	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);
	    
	    ## Pseudo weight
=pod

=item B<-pseudo pseudo_counts>

Pseudo-weight.

=cut
	} elsif ($arg eq "-pseudo") {
	    $main::pseudo_counts = shift(@arguments);
	    &RSAT::error::FatalError(join("\t", $main::pseudo_counts, 
					  "Invalid value for a pseudo-weight. Must be a positive real number."))
		unless ((&RSAT::util::IsReal($main::pseudo_counts) )
			&& ($main::pseudo_counts >= 0));


	    ## Equiprobable distribution of the pseudo-weight
=pod

=item B<-equi_pseudo>

If this option is called, the pseudo-weight is distributed in an equiprobable
way between residues.

By default, the pseudo-weight is distributed proportionally to residue priors.

=cut

	} elsif ($arg eq "-equi_pseudo") {
	    $main::equi_pseudo = 1;

	## Origin
=pod

=item B<-origin pos>

Define pos as the origin for the calculation of positions.

-origin -0 defines the end of each sequence as the origin. The matching
positions are then negative values, providing the distance between the match
and the end of the sequence.

=cut

	} elsif ($arg eq "-origin") {
	    $main::origin = shift(@arguments);
	    &RSAT::error::FatalError("$main::origin. Invalid origin, should be an Integer number.")
		unless (($main::origin eq "-0") || (&RSAT::util::IsInteger($main::origin)));


	    ## base for the logarihtms in the weight
=pod

=item	B<-base #>

Base for the logarithms used in the log likelihood score (weight). Default: e.

=cut
	} elsif ($arg eq "-base") {
	    $base = shift @arguments;
	    &RSAT::error::FatalError("base should be a real number") unless (&IsReal($base));
	    &RSAT::error::FatalError("base should be larger than 1") if ($base <= 1);

	    ## Number of decimals for the score
=pod

=item B<-decimals #>

Number of decimals displayed for the weight score.

Warning: the computation of P-values increases exponentially with the
number of decimals. For matrices wih many columns, this can become
non-tractable. We thus recommend to use the default value (2
decimals).

=cut

	} elsif ($arg eq "-decimals") {
	    $decimals = shift @arguments;
	    &RSAT::error::FatalError("decimals should be a positive integer") unless ((&IsNatural($decimals)) && ($decimals >= 0));

	    ## Thresholds
=pod
    
=item	B<-lth param lower_threshold>

=item	B<-uth param upper_threshold>

Threshold on some parameter (-lth: lower, -uth: upper threshold). 

Supported threshold fields for the matches : score, pval, eval, sig, normw, proba_M, proba_B, rank

Supported threshold fields for score distributions: occ occ_sum inv_cum exp_occ occ_pval occ_eval occ_sig occ_sig_rank

=cut

	    ### Lower threshold
	} elsif ($arg eq "-lth") {
	    my $thr_field = lc(shift(@arguments));
	    my $thr_value =  lc(shift(@arguments));
	    unless ($supported_threshold{$thr_field}) {
		&RSAT::error::FatalError("Invalid threshold field $thr_field. Supported: $supported_thresholds");
	    }
	    &RSAT::error::FatalError($thr_value, "Invalid value for a lower threshold. Should be a real number. ") 
	      unless (&RSAT::util::IsReal($thr_value));
	    $lth{$thr_field} = $thr_value;

	    ### Upper threshold
	} elsif ($arg eq "-uth") {
	    my $thr_field = lc(shift(@arguments));
	    my $thr_value = lc(shift(@arguments));
	    unless ($supported_threshold{$thr_field}) {
		&RSAT::error::FatalError("Invalid threshold field $thr_field. Supported: $supported_thresholds");
	    }
	    &RSAT::error::FatalError($thr_value, "Invalid value for an upper threshold. Should be a real number. ") 
	      unless (&RSAT::util::IsReal($thr_value));
	    $uth{$thr_field} = $thr_value;


	    ## Scan both strands
=pod

=item B<-2str>

Scan both strands for DNA sequences.

=cut
	} elsif ($arg eq "-2str") {
	    $main::both_strands = 1;

	    ## Scan direct strand only
=pod

=item B<-1str>

single-strand search for DNA sequences.

=cut
	} elsif ($arg eq "-1str") {
	    $main::both_strands = 0;


	    ## Return fields
=pod

=item B<-return return_fields>

List of fields to return. 

Supported fields: sites,ranks,limits,normw,bg_model,matrix,freq_matrix,weight_matrix

=over

=item B<sites:> Matching sites.

Return the position of each matching site, in a tab-delimited format
which can be sed as input by I<feature-map> (format .ft).

=item B<pval:> site-wise P-value

The site-wise P-value estimates the significance of the weight
associated to each site. It is computed from the matrix, according to
the probabilities described in Staden (1989), Bailey (1998).

In addition to the P-value, the program export a columns with the
significance, defined as sig = -log(P-value). By default, logarithms
are calculated in base 10, but this can be modified with the option
-base.

=item B<seq_scores:> sequence-wise score

Score each sequence according to Bailey (1998), with the difference
that, instead of computing the product of P-values, we compute the sum
of significances.

=item B<rank:> Rank.

Sort the sites per decreasing values of score (weight), and return the
rank value. The rank is calculated independently for each sequence.

A common usage of the rank is to select the top scoring site per
sequence (-uth rank 1) or the 3 top scoring sites per sequence (-uth
rank 3).

=item B<normw:> normalized weights.

Normailzed weights are calculated according to Thijs' formula : normw
= (W -Wmin)/(Wmax - Wmin). Note that Wmin and Wmax are approximated
using a Bernoulli model, for reasons of commputational efficiency.


=item B<limits:> limits (start, end) of the input sequences. 

This is useful for drawing feature maps with sequences of different
lengths.

=item B<distrib> Score distribution.

Return the score distribution for each matrix.

=item B<occ_proba> Probability of the number of matches in the input sequence

For each matrix and each score value, calculate the statistical
significance of the number of matches. This allows to select the score
associated with te maximal significance, on the basis of the
matrix-specific distribution, rather than by selecting some a priori
threshold.

For each motif (M) and each score value (s), the program estimates the
significance of the observed number of matches (x), given the prior
probability (p) to find an instance of this motif with at least this
score at a given position of the sequence. The P-value is calculated
using the binomial distribution (Aerts et al., 2003).

This option requires to specify a background score distribution
(option -bg_distrib) to estimate the prior probabilities of motif
instances.

=item B<bg_model:> Background model.

Report the transition matrix of the background model. Note that this
option only makes sense for fixed background models (-bgfile or
-bginput), since when the background model is adaptive (-mindow), the
transition matrix changes along he sequence.

=back

=cut
        } elsif ($arg eq "-return") {
	  $arg = shift (@arguments);
	  chomp($arg);
	  my @fields_to_return = split ",", $arg;
	  foreach my $field (@fields_to_return) {
	    $field = lc($field);
	    if ($supported_return_fields{$field}) {
	      $return_fields{$field} = 1;
	    } else {
	      &RSAT::error::FatalError(join("\t", $field, "Invalid return field. Supported:", $supported_return_fields));
	    }
	  }


	    ## Sort score distribution by decreasing sig value
=pod

=item B<-sort_distrib>

Sort score distribution by decreasing value of significance. By
default, the score distributions are sorted by score (weight).

=cut
	} elsif ($arg eq "-sort_distrib") {
	    $main::sort_distrib = 1;

	    ## Background score distribution
=pod

=item B<-bg_distrib bg_distrib_file>

File specifying the background score distribution used to estimate
prior probabilities with the option -return occ_proba. When this file
is specified, the prior probabilities of motif occurrences are
estimated from the frequencies of the background file, rather than
using the theoretical site-wise P-value.

This background distribution can be generated by running matrix-scan
on a set of background sequences, with the options

=over

matrix-proba -v 1 -return distrib -mlist matrix_list.txt -i bg_seq.fta [...]

=back

Various types of background sequences can be used as background model:
whole genome, whole set of upstream sequences, randomly generated
sequences, ... The choice of the background model has a strong effect
on the estimated significance, and should thus be done carefully,
according to the biological question.


=cut
	} elsif ($arg eq "-bg_distrib") {
	  $main::infile{bg_distrib} = shift(@arguments);
	  
	  ## Batch method
	  
=pod

=item B<-recursive>

Run matrix-scan separately for each sequence.

=cut
	} elsif ($arg eq "-recursive") {
	    $batch = 1;
	    
=pod

=item B<-batch #>

Dispatch matrix-scan jobs on a cluster.
Number of sequences to be analyzed by job (= on each node of the cluster)

=cut
	} elsif ($arg eq "-batch") {
	    $cluster = shift(@arguments);
	   	# set minimum sequences to be analyzed to 1
	    $cluster =1 if ($cluster eq "");
	    &RSAT::error::FatalError("# sequences for the cluster must be a natural number.") 
	    unless &RSAT::util::IsNatural($cluster)&&($cluster > 0);

	    

	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
  }


}

################################################################
#### verbose message
sub Verbose {

    ## Report the command line
    print $main::out "; matrix-scan ";
    &PrintArguments($main::out);

    ## Input files
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::out ";\t$key\t$value\n";
	}
	print $main::out "; Matrix files\n";
	for my $m (0..$#matrix_files) {
	    printf $out ";\tmatrix %d\t%s\n", $m+1, $matrix_files[$m];
	}

    }
    printf $main::out "; %-21s\t%s\n", "Sequence format", $seq_format;

    ## Output files
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }

    ## Pseudo counts
    printf $main::out "; %-21s\t%s\n", "Pseudo counts", $pseudo_counts;

    ## Background model
    if (defined($bg_model)) {
   	printf $main::out "; Background model\n";
	my $order = $bg_model->get_attribute("order");
   	printf $main::out ";\t%-14s\t%s\n", "Method", $bg_method;
    if ($order == 0) {
	printf $main::out ";\t%-14s\n", "Bernoulli model (order=0)";
    } else {
	printf $main::out ";\t%-14s\t%d\n", "Markov order", $order;
    }
    printf $main::out ";\t%-14s\t%s\n", "Strand", $bg_model->get_attribute("strand");
    if ($window > 0) {
	printf $main::out ";\t%-14s\t%d\n", "Background window", $window;
    }
    my %bg_prior = $bg_model->get_attribute("suffix_proba");
    print $main::out ";\tResidue probabilities\n";
    foreach my $residue (sort keys %bg_prior) {
	printf $main::out ";\t\t%s\t%.5f\n", $residue, $bg_prior{$residue};
    }

    my $missing_transitions = $bg_model->get_attribute("missing_transitions");
    if ($missing_transitions > 0) {
      printf $main::out ";\t%-14s\t%d %s\n", "WARNING", , $missing_transitions, "missing transitions. You should reduce the Markov order";
    }
    }


    ## Thresholds
    my %th_keys = (%lth, %uth);
    print $main::out "; Thresholds\tlower\tupper\n";
    foreach $f (sort keys %th_keys) {
	print $main::out ";\t$f";
	if (defined($lth{$f})) {
	    printf $main::out "\t%-5g", $lth{$f};
	} else {
	    print $main::out "\t", $null;
	}
	if (defined($uth{$f})) {
	    printf $main::out "\t%-5g", $uth{$f};
	} else {
	    print $main::out "\t", $null;
	}
	print $main::out "\n";
    }


}


################################################################
=pod

=head1 INTERNAL PROCEDURES

=cut

################################################################
=pod

=item B<score_segment>

Assign a score to a sequence segment and print it if it passes the
thresholds. Return value is 1 if the segment passed the thresholds.

=cut
sub score_segment {
    my ($segment, $matrix, $seq_id, $pos, $strand) = @_;
    my $ncol = $matrix->{ncol};
    my $proba_M = 1;
    my $proba_B = 1;
    my $matrix_name = $matrix->get_attribute("name");

    $matrix->{scored}++;
    $sequence_scores->{$seq_id}->{scored}++;

    $proba_M = $matrix->segment_proba($segment);

    $proba_B = $bg_model->segment_proba($segment);

    ## Calculate segment weight and  normalized weight
    my $score = $null;
    my $normw = $null;
    my $pval = $null;
    my $ln_pval = $null;
    if (($proba_M > 0) && ($proba_B > 0)) {
      $score = log($proba_M/$proba_B)/$log_base;
#      $score = $matrix->segment_weight_Bernoulli($segment);
      $score = sprintf("%.${decimals}f", $score);
      $score =~ s/^-(0.0+)$/$1/; ## Suppress the difference between -0.0 and +0.0 after the rounding
	if ($calc_fields{normw}) {
	  $normw = sprintf("%6.4f", ($score - $matrix->{Wmin})/($matrix->{Wrange}));
	}
	if ($calc_fields{pval}) {
	  if (defined(${$main::pval{$matrix}}{$score})) {
	    $pval_value = ${$main::pval{$matrix}}{$score};
	    $pval = sprintf("%.1e", $pval_value);
	    if ($pval_value > 0) {
	      $ln_pval = sprintf("%.3f", log($pval_value));
	      $sig = sprintf("%.3f", -log($pval_value)/$sig_base);
	    } else {
	      $ln_pval = "-Inf";
	      $sig = "Inf";
	    }
	  }
	}
    } elsif ($proba_M == 0) {
	if ($proba_B > 0) {
	    $score = "-Inf";
	    $normw = 0 if ($calc_fields{normw});
	    if ($calc_fields{pval}) {
	      $pval = 0;
	      $ln_pval = "-Inf";
	      $sig = "Inf";
	    }
	}
    }

    if ($return_fields{distrib}) {
#      my $score = sprintf("%.${decimals}f", $score);
      $score_distrib->{$matrix_name}->{$score}->{occ}++;
    }
#    &RSAT::message::Debug("scoring segment", $segment, $seq_id, $pos, $strand, 
#			  $proba_M , $proba_B, $score) if ($main::verbose >= 10);


    ## Perform the threshold filtering only after having added the score to the disribution
    return(0) unless (&check_thresholds("proba_m", $proba_M));
    return(0) unless (&check_thresholds("proba_b", $proba_B));
    return(0) unless (&check_thresholds("pval_value", $pval_value));
    return(0) unless (&check_thresholds("pval", $pval));
    return(0) unless (&check_thresholds("ln_pval", $ln_pval));
    return(0) unless (&check_thresholds("sig", $sig));
    return(0) unless (&check_thresholds("score", $score));
    return(0) unless (&check_thresholds("normw", $normw));

#    &RSAT::message::Debug("match", $seq_id, $score, $pval, $ln_pval, $sig_base, $sig) if ($main::verbose >= 10);

    ## Calculate information
#    my $info = $score * $proba_B;
#    return(0) unless (&check_thresholds("info", $info));

    $matrix->{matches}++;

    ## Update sequence-wise scores
    if ($return_fields{seq_scores}) {
      $sequence_scores->{$seq_id}->{matches}++;
      $sequence_scores->{$seq_id}->{weight_sum}+= $score;
      $sequence_scores->{$seq_id}->{sig_sum}+= $sig;
    }

    ## ##############################################################
    ## Create a new object for the current match BEWARE: this can
    ## consume a lot of memory if the options are to return all the
    ## matches. A memory-saving possibility was to print the matches
    ## progressively and forget them, but this would prevent from
    ## sorting the matches by score.
#    &RSAT::message::Debug("Creating a fteaure for new match") if ($main::verbose >= 10);
    if ($return_fields{sites}) {
      ## Calculate start and end position
      my $start_pos = $pos - $orig_pos;
      my $end_pos = $start_pos + $ncol -1;
      my $match = new RSAT::feature();
      $match->set_attribute('seq_name', $seq_id);
      $match->set_attribute('ft_type', 'site');
      $match->set_attribute('feature_name', $matrix->get_attribute('name'));
      $match->set_attribute('strand',$strand);
      $match->set_attribute('start',$start_pos);
      $match->set_attribute('end',$end_pos);
      $match->set_attribute('description',uc($segment));
      $match->set_attribute('score',$score);
      $match->set_attribute('proba_M',$proba_M);
      $match->set_attribute('proba_B',$proba_B);
      if ($return_fields{pval}) {
	$match->set_attribute('pval',$pval);
	$match->set_attribute('ln_pval',$ln_pval);
	$match->set_attribute('sig',$sig);
      }
      $match->set_attribute('normw',$normw) if ($return_fields{normw});
      #    if (($calc_fields{rank}) || ($calc_fields{pval})){
      # If the hits have to be ranked, store them rather than printing them immediately
     # push @matches , $match;
    #  push @{$matches_per_matrix{$matrix->get_attribute('name')}} , $match;
      push @{$matches_per_seq{$seq_id}} , $match;
    }
#      push @{$sequence_scores->{$seq_id}->matches} , $match if ($return_fields{seq_scores});
#    } else {
#      &print_match($match) if ($main::return_fields{sites});
#    }
    return(1);
}


################################################################
=pod

=item B<print_match>

Print the matching site.

=cut

sub print_match {
    my ($match) = @_;

    print $out join ("\t", 
		     $match->get_attribute('seq_name'),
		     $match->get_attribute('ft_type'),
		     $match->get_attribute('feature_name'),
		     $match->get_attribute('strand'),
		     $match->get_attribute('start'),
		     $match->get_attribute('end'),
		     $match->get_attribute('description'),
		     $match->get_attribute('score'),
		     sprintf("%5.2g\t%5.2g",
			     $match->get_attribute('proba_M'),
			     $match->get_attribute('proba_B')
			     )
		     );
#			 "site",
#			 $matrix->{name},
#			 $strand,
#			 $start_pos,
#			 $end_pos,
#			 $segment,
#			 $score,
#			 sprintf("%5.2g\t%5.2g",
#				 $proba_M,
#				 $proba_B,
#				)
    if ($return_fields{pval}) {
      print $out "\t", $match->get_attribute('pval');
      print $out "\t", $match->get_attribute('ln_pval');
      print $out "\t", $match->get_attribute('sig');
    }
    print $out "\t", $match->get_attribute('normw') if ($return_fields{normw});
    print $out "\t", $match->get_attribute('rank') if ($return_fields{rank});
    print $out "\n";
}

# ################################################################
# =pod

# =item B<print_match>

# Print the matching site.

# =cut

# sub print_match {
#     my ($match) = @_;

#     print $out join ("\t", 
# 		     $match->get_attribute('seq_name'),
# 		     $match->get_attribute('ft_type'),
# 		     $match->get_attribute('feature_name'),
# 		     $match->get_attribute('strand'),
# 		     $match->get_attribute('start'),
# 		     $match->get_attribute('end'),
# 		     $match->get_attribute('description'),
# 		     $match->get_attribute('score'),
# 		     sprintf("%5.2g\t%5.2g",
# 			     $match->get_attribute('proba_M'),
# 			     $match->get_attribute('proba_B')
# 			     )
# 		     );
# #			 "site",
# #			 $matrix->{name},
# #			 $strand,
# #			 $start_pos,
# #			 $end_pos,
# #			 $segment,
# #			 $score,
# #			 sprintf("%5.2g\t%5.2g",
# #				 $proba_M,
# #				 $proba_B,
# #				)
    
#     print $out "\t", $match->get_attribute('normw') if ($return_fields{normw});
#     print $out "\t", $match->get_attribute('rank') if ($return_fields{rank});
#     print $out "\n";
# }

################################################################
=pod

=item B<check_thresholds>

Check the lower and upper threshold for a given hit.

=cut
sub check_thresholds {
    my ($key, $value) = @_;
    if ((defined($lth{$key})) && 
	(($value eq $null) || ($value < $lth{$key}))
       ) {
	return 0;
    }
    if ((defined($uth{$key})) && 
	(($value eq $null) || ($value > $uth{$key}))
       ) {
	return 0;
    }
    return 1;
}

################################################################
=pod

=item B<check_distrib_thresholds>

Check the lower and upper threshold for a given parameter in the score
distribution.

=cut
sub check_distrib_thresholds {
  my ($key) = @_;
  $key = lc($key); ## case-insensitive keys

  ## Check lower thresholds
  if (defined($lth{$key})) {
    &RSAT::message::TimeWarn("Checking lower threshold on score distibution", 
			     $key, $lth{$key}) if ($main::verbose >= 2);
    foreach my $matrix (@matrices) {
      my $matrix_name = $matrix->get_attribute("name");
      my @sorted_scores = sort {$a <=> $b} keys %{$score_distrib->{$matrix_name}};
      &RSAT::message::Info("score range", $matrix_name, $sorted_scores[0], $sorted_scores[$#sorted_scores], scalar(@sorted_scores)) if ((scalar(@sorted_scores) >= 1) && ($main::verbose >= 3));
      foreach my $score (@sorted_scores) {
	if (($score_distrib->{$matrix_name}->{$score}->{$key} eq $null) || 
	    ($score_distrib->{$matrix_name}->{$score}->{$key} < $lth{$key})) {
	  &RSAT::message::Info("Deleting distribution item", $matrix_name, $score, 
			       $key, $score_distrib->{$matrix_name}->{$score}->{$key},
			       ' < lth', $lth{$key}) if ($main::verbose >= 5);
	  delete($score_distrib->{$matrix_name}->{$score});
	}
      }
      &RSAT::message::Info("Remaining distribution items", $matrix_name, 
			  scalar(keys %{$score_distrib->{$matrix_name}})) if ($main::verbose >= 2);
    }
  }

  ## Check upper thresholds
  if (defined($uth{$key})) {
    &RSAT::message::TimeWarn("Checking upper threshold on score distibution", 
			     $key, $uth{$key}) if ($main::verbose >= 2);
    foreach my $matrix (@matrices) {
      my $matrix_name = $matrix->get_attribute("name");
      my @sorted_scores = sort {$a <=> $b} keys %{$score_distrib->{$matrix_name}};
      &RSAT::message::Info("score range", $matrix_name, $sorted_scores[0], $sorted_scores[$#sorted_scores], scalar(@sorted_scores)) if ((scalar(@sorted_scores) >= 1) && ($main::verbose >= 3));
      foreach my $score (@sorted_scores) {
	if (($score_distrib->{$matrix_name}->{$score}->{$key} eq $null) || 
	    ($score_distrib->{$matrix_name}->{$score}->{$key} > $uth{$key})) {
	  &RSAT::message::Info("Deleting distribution item", $matrix_name, $score, 
			       $key, $score_distrib->{$matrix_name}->{$score}->{$key},
			       ' > uth', $uth{$key}) if ($main::verbose >= 5);
	  delete($score_distrib->{$matrix_name}->{$score});
	}
      }
      &RSAT::message::Info("Remaining distribution items", $matrix_name, 
			   scalar(keys %{$score_distrib->{$matrix_name}})) if ($main::verbose >= 2);
    }
  }
}


################################################################
## Print the start and end positions of the sequence
sub PrintSequenceLimits {
    my ($seq_id, $seq_len, $orig_pos) = @_;

    print $main::out join ("\t", 
			   $seq_id,
			   "limit",
			   "SEQ_START",
			   "DR",
			   1-$orig_pos,
			   1-$orig_pos,
			   ".",
			  ), "\n";
    print $main::out join ("\t", 
			   $seq_id,
			   "limit",
			   "SEQ_END",
			   "DR",
			   $seq_len-$orig_pos,
			   $seq_len-$orig_pos,
			   ".",
			  ), "\n";
}


################################################################
## Print score distributions
sub PrintScoreDistrib {
  ## Print the header;
  print $out ";\n; Score distribution\n";
  my @header = ("matrix",
		"score",
		"occ",
		"occ_cum",
		"inv_cum",
		#		    "frequency",
		#		    "cum_freq",
		"inv_cum_freq",
#		"occ_prior",
	       );
  if ($return_fields{occ_proba}) {
    push @header, ("occ_prior",
		   "exp_occ",
		   "occ_Pval",
		   "occ_Eval",
		   "occ_sig",
		   "rank",
		  );
  }
  print $out "#", join  ("\t", @header), "\n";
  &RSAT::message::TimeWarn("Printing score distributions") if ($main::verbose >= 2);
  foreach my $matrix (@matrices) {
    my $matrix_name = $matrix->get_attribute("name");
    my @sorted_scores = sort {$a <=> $b} keys %{$score_distrib->{$matrix_name}};

    &RSAT::message::Info("score range", $matrix_name, $sorted_scores[0], $sorted_scores[$#sorted_scores], scalar(@sorted_scores)) if ((scalar(@sorted_scores) >= 1) && ($main::verbose >= 3));

    if (($return_fields{occ_proba}) && ($sort_distrib)) {
      @sorted_scores =  sort {
	$score_distrib->{$matrix_name}->{$a}->{occ_pval} <=> $score_distrib->{$matrix_name}->{$b}->{occ_pval}
      } keys %{$score_distrib->{$matrix_name}};
      &RSAT::message::Info("Sorting distribution by occ_pval") if ($main::verbose >= 4);
    }
      
    #	@sorted_scores = sort {$a <=> $b} keys(%{$pval{$matrix}});
      
    my $occ_sig_rank = 0;
    foreach my $score (@sorted_scores) {
	
      ## Calculate occ_sig_rank and check thresholds on occ_sig_rank
      $occ_sig_rank++;
      if ((defined($lth{occ_sig_rank})) && ($occ_sig_rank < $lth{occ_sig_rank})) {
	delete($score_distrib->{$matrix_name}->{$score});
	next;
      }
      if ((defined($uth{occ_sig_rank})) && ($occ_sig_rank > $uth{occ_sig_rank})) {
	delete($score_distrib->{$matrix_name}->{$score});
	next;
      }
	
      my $occ = $score_distrib->{$matrix_name}->{$score}->{occ};
      my $occ_cum = $score_distrib->{$matrix_name}->{$score}->{occ_cum};
      my $inv_cum = $null;
      my $freq_inv_cum = $null;
      if (defined ($score_distrib->{$matrix_name}->{$score}->{inv_cum})) {
	$inv_cum = $score_distrib->{$matrix_name}->{$score}->{inv_cum};
	$freq_inv_cum = sprintf("%.6e", $inv_cum/$cum_sum{$matrix_name});
      }

      ## P-value of a hit at a single position, for the considered score
#      my $occ_prior = $null;
#      if (defined(${$main::pval{$matrix}}{$score})) {
#	$occ_prior = sprintf("%.1e", ${$main::pval{$matrix}}{$score});
#      }

      print $out join ("\t",
		       $matrix->get_attribute("name"),
		       $score,
		       $occ,
		       $occ_cum,
		       $inv_cum,
		       #			   sprintf("%.6e", $occ/$cum_sum{$matrix_name}),
		       #			   sprintf("%.6e", $occ_cum/$cum_sum{$matrix_name}),
		       $freq_inv_cum,
#		       $occ_prior,
		      );
      if ($return_fields{occ_proba}) {
	my $occ_prior = $null;
	my $exp_occ = $null;
	if (defined($score_distrib->{$matrix_name}->{$score}->{occ_prior})) {
	  $distrib_prior = sprintf("%.6e", $score_distrib->{$matrix_name}->{$score}->{occ_prior});
	  $exp_occ = sprintf("%.2f", $score_distrib->{$matrix_name}->{$score}->{exp_occ});
	}

	## Format pval for printing
	my $occ_pval = $null;
	if (defined($score_distrib->{$matrix_name}->{$score}->{occ_pval})) {
	  $occ_pval = sprintf("%.6e", $score_distrib->{$matrix_name}->{$score}->{occ_pval});
	}

	## Format eval for printing
	my $occ_eval = $null;
	if (defined($score_distrib->{$matrix_name}->{$score}->{occ_eval})) {
	  $occ_eval = sprintf("%.6e", $score_distrib->{$matrix_name}->{$score}->{occ_eval});
	}

	## Format occ_sig for printing
	my $occ_sig = $null;
	if (defined($score_distrib->{$matrix_name}->{$score}->{occ_sig})) {
	  $occ_sig = sprintf("%.2f", $score_distrib->{$matrix_name}->{$score}->{occ_sig});
	}

	print $out "\t", join ("\t", 
			       $distrib_prior,
			       $exp_occ,
			       $occ_pval,
			       $occ_eval,
			       $occ_sig,
			       $occ_sig_rank,
			      );
      }
      print $out "\n";
    }
  }
}

################################################################
## Run matrix-scan in batch mode
sub runInBatch {
	
	&RSAT::message::Info("Batch: running matrix-scan for each sequence separately") 
 	if ($main::verbose >= 1);
 	local($current_seq, $seq_id);
 	my $seq_total;
 	my $wd = `pwd`;
    chomp $wd;
    local $ENV{'CLUSTER_QUEUE'} = "default";
 	
 	## calculate total number of sequences if cluster
 	if ($cluster != 0) {
 		my ($in, $input_dir) = &OpenInputFile($main::infile{input});
 		while ((($current_seq, $seq_id) = &ReadNextSequence($in, $seq_format, $input_dir, "",$mask)) &&
			(($current_seq ne "") || ($seq_id ne ""))) {
			$seq_total++;
			}
		close $in;
		&RSAT::message::Info("Total number of sequences to analyse: $seq_total ") 
 		if ($main::verbose >= 2);
 	}
    
    ## get each sequence
    my ($in, $input_dir) = &OpenInputFile($main::infile{input});
  	while ((($current_seq, $seq_id) = &ReadNextSequence($in, $seq_format, $input_dir, "",$mask)) &&
	(($current_seq ne "") || ($seq_id ne ""))) {
		
		$sequence_number++;
		my $seq_len = length($current_seq);
    	$sum_seq_len += $seq_len;
		
		$main::outfile{"seq".$sequence_number."tab"} = "seq".$sequence_number."_".$seq_id.".matrix_scan.tab";
		push (@temp_output_files, $main::outfile{"seq".$sequence_number."tab"});
		
		##copy the sequence in a file (fasta format)
		$main::outfile{"seq".$sequence_number} = "seq".$sequence_number."_".$seq_id.".".$seq_format;
		push (@temp_fasta_files, $main::outfile{"seq".$sequence_number});		
		$seq_handle = &OpenOutputFile($main::outfile{"seq".$sequence_number});
    	&PrintNextSequence($seq_handle, $seq_format,60,$current_seq,$seq_id);
    	close $seq_handle;
    	    	   	
		##matrix-scan command with absolute path in case of use with the cluster
  		my $matrix_scan_cmd = "matrix-scan ";
  		$matrix_scan_cmd .= " -v ".$main::verbose;
  		## bg model
  		if ($bg_method eq "file") {
  			$matrix_scan_cmd .= " -bgfile ".File::Spec->rel2abs($main::infile{bg},$wd);
  		} elsif ($bg_method eq "input") {
  			$matrix_scan_cmd .= " -bginput ";
  			$matrix_scan_cmd .= " -markov ".$main::markov;
  		} elsif ($bg_method eq "window") {
  			$matrix_scan_cmd .= " -markov ".$main::markov;
  			$matrix_scan_cmd .= " -window ".$main::window;
  		}
  		## matrix
  		if (scalar(@matrix_files >= 1)) {
  			$matrix_scan_cmd .= " -m ";
  			my @matrix_files_absolute =();
  			foreach my $mpath (@matrix_files){
  				push (@matrix_files_absolute,File::Spec->rel2abs($mpath,$wd));
  			}
  			$matrix_scan_cmd .= join(" ", @matrix_files_absolute);
  		} elsif ($main::infile{matrix_list}){
  			$matrix_scan_cmd .= " -mlist ".File::Spec->rel2abs($main::infile{matrix_list},$wd);
  		}
  		$matrix_scan_cmd .= " -matrix_format ".$matrix_format;
  		$matrix_scan_cmd .= " -pseudo ".$main::pseudo_counts;
  		if ($main::equi_pseudo == 1) {
  			$matrix_scan_cmd .= " -equi_pseudo ";
  		}
  		if ($consensus_name eq 1) {
  			$matrix_scan_cmd .= " -consensus_name ";
  		}
  		## sequence
  		$matrix_scan_cmd .= " -seq_format ".$seq_format;
  		$matrix_scan_cmd .= " -i ".File::Spec->rel2abs($main::outfile{"seq".$sequence_number}, $wd);
  		if ($main::mask){
  			$matrix_scan_cmd .= " -mask ".$main::mask;
  		}
  		
  		$matrix_scan_cmd .= " -n ".$main::n_treatment;
  		$matrix_scan_cmd .= " -origin ".$main::origin;
  		## scoring
  		if ($base != exp(1)){
  			$matrix_scan_cmd .= " -base ".$base;
  		}
  		$matrix_scan_cmd .= " -decimals ".$decimals;
  		if ($main::both_strands == 1) {
  			$matrix_scan_cmd .= " -2str ";
  		} else {
  			$matrix_scan_cmd .= " -1str ";
  		}
  		## thresholds
  		if (scalar(keys(%lth)) > 0) {
  			$matrix_scan_cmd .= " -lth ";
  			foreach my $field (keys(%lth)) {
    		$matrix_scan_cmd .= " $field $lth{$field} ";
  			}
  		}
  		if (scalar(keys(%uth)) > 0) {
  			$matrix_scan_cmd .= " -uth ";
  			foreach my $field (keys(%uth)) {
    		$matrix_scan_cmd .= " $field $uth{$field} ";
  			}
  		}
  		## output
  		$matrix_scan_cmd .= " -o ".File::Spec->rel2abs($main::outfile{"seq".$sequence_number."tab"},$wd);
		&RSAT::message::Warning("The batch option is intended to report the sites.") unless ($return_fields{sites});
		$matrix_scan_cmd .=  " -return sites";
  		if ($return_fields{pval}) {
  			$matrix_scan_cmd .=  ",pval";
  		}
  		if ($return_fields{rank}) {
  			$matrix_scan_cmd .=  ",rank";
  		}
  		if ($return_fields{limits}) {
  			$matrix_scan_cmd .=  ",limits";
  		}
  		if ($return_fields{normw}) {
  			$matrix_scan_cmd .=  ",normw";
  		}
  		if (($return_fields{distrib})||($return_fields{occ_proba})||($return_fields{matrix})||
  		($return_fields{freq_matrix})||($return_fields{weight_matrix})||($return_fields{bg_model})||
  		($return_fields{seq_scores})){
  		&RSAT::error::FatalError("The batch option is incompatible with -return distrib,occ_proba,matrix,freq_matrix,weight_matrix,bg_model,seq_scores");
  		}
  		
  		## send jobs to cluster queue
  		if ($cluster != 0) {
  			$cluster_cmd .= "\n".$matrix_scan_cmd;
  			if (&RSAT::util::IsNatural($sequence_number/$cluster)||($sequence_number == $seq_total)){
  				&RSAT::message::TimeWarn("Sending $job_prefix job for seq".($sequence_number-$cluster+1)."-".$sequence_number)
 				if ($main::verbose >= 2);
 				## Execute the command
  				&doit($cluster_cmd, $dry, $die_on_error, $verbose,1, $job_prefix);
  				$cluster_cmd="";
  			}
  		}
  		else {
			&RSAT::message::TimeWarn("Executing $job_prefix for seq #$sequence_number $seq_id ") 
 			if ($main::verbose >= 2);
  			## Execute the command
  			&doit($matrix_scan_cmd, $dry, $die_on_error, $verbose, $batchmode, $job_prefix);	
  			}
	 	}
	 	
	 	close $in;
	 	
	 	## check that all jobs are finished on the cluster
	 	if ($cluster != 0) {
	 		&areJobsDone($wd);
	 	}
	 	
	 	## Merge results
	 	&RSAT::message::TimeWarn("Merge matrix-scan results of each separate sequence") 
 		if ($main::verbose >= 2);
 		
	 	## Put all individual results in one file 
	 	$main::outfile{output_raw} = $main::outfile{output}.".raw";
    	if (scalar(@temp_output_files) > 0) {
    		my $merge_cmd = "cat ";
    		$merge_cmd .= join (" ", @temp_output_files);
    		$merge_cmd .= " > $main::outfile{output_raw}";
    		&doit($merge_cmd, $dry, $die_on_error, $verbose, $batchmode, $job_prefix);
    	}
    		
    	## Extract the names of the fields returned
    	open (SYSTEM, "grep -m 1 '^#' $main::outfile{output_raw} |");	
 		my $header = <SYSTEM>;
		close (SYSTEM);
		print $main::out $header;
		
    	## Extract the sites from the merged file    
    	## could add a sort in the command 
		open (SYSTEM, "grep -v '^;' $main::outfile{output_raw} | grep -v '^#' | ");
		while (<SYSTEM>) {
			print $main::out $_;
			}
		close (SYSTEM);

	 	## Keep the verbosity lines in a log file    
		$main::outfile{output_log} = $main::outfile{output}.".log";
		my $log_cmd = "grep '^;' $main::outfile{output_raw} > $main::outfile{output_log} ";
		&doit($log_cmd, $dry, $die_on_error, $verbose, $batchmode, $job_prefix);
	 	
	 	## Sequence statistics
    	printf $main::out "; %-21s\t%s\n", "Number of sequences scanned", $sequence_number;
    	printf $main::out "; %-21s\t%s\n", "Sum of sequence lengths", $sum_seq_len;
	 	
	 	my $done_time = &AlphaDate();
 	    print $main::out "; Job started $start_time\n";
 	    print $main::out "; Job done    $done_time\n";
}

################################################################
## Run matrix-scan in batch mode
sub areJobsDone {
	my $wd = shift;
	sleep 15;
	
## temporary method using qstat
#   local $user =  `whoami`;
#   chomp($user);
#	 		my $finished = 0;
#	 		while ($finished == 0){
#	 			sleep 30;
#	 			open (SYSTEM, "qstat | grep $user|grep $job_prefix | wc -l|");	
# 				my $job_running = <SYSTEM>;
#				close (SYSTEM);
#				chomp($job_running);
#				&RSAT::message::TimeWarn("Still $job_running jobs running... ") 
# 				if ($main::verbose >= 4);
#				$finished=1 if ($job_running == 0);
#			}
##
	 ## method using the .start and .done files
	 my %jobs_status = ();	 		
	 my $job_dir = $wd."/jobs/".`date +%Y%m%d`;
	 chomp($job_dir);
	 		
	 ## get all jobs file
	 opendir(JOBDIR, $job_dir) || die "can't opendir $job_dir: $!";
	 my @job_dir_content = grep { !/^\./ } readdir(JOBDIR);
	 closedir JOBDIR;
     foreach my $file (@job_dir_content){
    	unless (($file !~ /^$job_prefix/)||($file =~ /$job_prefix\.\w+\.\w+/)) { #only consider matrix-scan job, not .start or .done files
    		$jobs_status{$file}= "unknown";
    	}			
    }
    		
    ## check the .start and .done files
	my $finished = keys(%jobs_status);
	my $current_status = 0;

	until ($current_status == $finished) {
		sleep 30;
		$current_status = 0;
    	if (scalar(keys(%jobs_status)) > 0) {
  			foreach my $job (keys(%jobs_status)) {
  				if (-e $job_dir."/".$job.".done") {
  					$jobs_status{$job} = "done";
  					$current_status += 1;
  				}
  				elsif (-e $job_dir."/".$job.".started") {
  					$jobs_status{$job} = "started";
  				}
  			}
    	}
    	&RSAT::message::TimeWarn("Still ".($finished-$current_status)."jobs running...") 
 		if ($main::verbose >= 2);
	}
	return (1);
}


__END__
    
=pod

=head1 SEE ALSO

=over

=item I<convert-matrix>

=item I<convert-background-model>

=item I<feature-map>

=back

=cut




################################################################
####################### IN DEVELOPMENT #########################
################################################################


# ################################################################
# =pod

# =item B<score_sequence>

# Assign a score to a each position of sequence and print the matches if
# they pass the thresholds.

# =cut
# sub score_sequence {
#     my ($sequence, $matrix, $seq_id) = @_;
#     my $ncol = $matrix->{ncol};
#     my $matrix_name = $matrix->get_attribute("name");

#     my @proba_M = $matrix->seq_proba($sequence);
#     my @proba_B = $bg_model->seq_proba($sequence);

#     for my $i (0..$#proba_M) {
#       $matrix->{scored}++;
#       $sequence_scores->{$seq_id}->{scored}++;
#       my $proba_M = $proba_M[$i];
#       my $proba_B = $proba_B[$i];

#       ## Calculate segment weight and  normalized weight
#       my $score = $null;
#       my $normw = $null;
#       my $pval = $null;
#       my $ln_pval = $null;
#       if (($proba_M > 0) && ($proba_B > 0)) {
# 	$score = log($proba_M/$proba_B)/$log_base;
# 	#      $score = $matrix->segment_weight_Bernoulli($segment);
# 	$score = sprintf("%.${decimals}f", $score);
# 	$score =~ s/^-(0.0+)$/$1/; ## Suppress the difference between -0.0 and +0.0 after the rounding
# 	if ($calc_fields{normw}) {
# 	  $normw = sprintf("%6.4f", ($score - $matrix->{Wmin})/($matrix->{Wrange}));
# 	}
# 	if ($calc_fields{pval}) {
# 	  if (defined(${$main::pval{$matrix}}{$score})) {
# 	    $pval_value = ${$main::pval{$matrix}}{$score};
# 	    $pval = sprintf("%.1e", $pval_value);
# 	    if ($pval_value > 0) {
# 	      $ln_pval = sprintf("%.3f", log($pval_value));
# 	      $sig = sprintf("%.3f", -log($pval_value)/$sig_base);
# 	    } else {
# 	      $ln_pval = "-Inf";
# 	      $sig = "Inf";
# 	    }
# 	  }
# 	}
#       } elsif ($proba_M == 0) {
# 	if ($proba_B > 0) {
# 	  $score = "-Inf";
# 	  $normw = 0 if ($calc_fields{normw});
# 	  if ($calc_fields{pval}) {
# 	    $pval = 0;
# 	    $ln_pval = "-Inf";
# 	    $sig = "Inf";
# 	  }
# 	}
#       }
      
#       if ($return_fields{distrib}) {
# 	#      my $score = sprintf("%.${decimals}f", $score);
# 	$score_distrib->{$matrix_name}->{$score}->{occ}++;
#       }
#       #    &RSAT::message::Debug("scoring segment", $segment, $seq_id, $pos, $strand, 
#       #			  $proba_M , $proba_B, $score) if ($main::verbose >= 10);
      
      
#       ## Perform the threshold filtering only after having added the score to the disribution
#       next unless (&check_thresholds("proba_m", $proba_M));
#       next unless (&check_thresholds("proba_b", $proba_B));
#       next unless (&check_thresholds("pval_value", $pval_value));
#       next unless (&check_thresholds("pval", $pval));
#       next unless (&check_thresholds("ln_pval", $ln_pval));
#       next unless (&check_thresholds("sig", $sig));
#       next unless (&check_thresholds("score", $score));
#       next unless (&check_thresholds("normw", $normw));
#       #    &RSAT::message::Debug("match", $seq_id, $score, $pval, $ln_pval, $sig_base, $sig) if ($main::verbose >= 10);
#       ## Calculate information
#       #    my $info = $score * $proba_B;
#       #    return(0) unless (&check_thresholds("info", $info));

#       $matrix->{matches}++;
      
#       ## Update sequence-wise scores
#       if ($return_fields{seq_scores}) {
# 	$sequence_scores->{$seq_id}->{matches}++;
# 	$sequence_scores->{$seq_id}->{weight_sum}+= $score;
# 	$sequence_scores->{$seq_id}->{sig_sum}+= $sig;
#       }

#       ################################################################
#       ## Create a new object for the current match
#       #    &RSAT::message::Debug("Creating a fteaure for new match") if ($main::verbose >= 10);
#       if ($return_fields{sites}) {
# 	## Calculate start and end position
# 	my $start_pos = $pos - $orig_pos;
# 	my $end_pos = $start_pos + $ncol -1;
# 	my $match = new RSAT::feature();
# 	$match->set_attribute('seq_name', $seq_id);
# 	$match->set_attribute('ft_type', 'site');
# 	$match->set_attribute('feature_name', $matrix->get_attribute('name'));
# 	$match->set_attribute('strand',$strand);
# 	$match->set_attribute('start',$start_pos);
# 	$match->set_attribute('end',$end_pos);
# 	$match->set_attribute('description',uc($segment));
# 	$match->set_attribute('score',$score);
# 	$match->set_attribute('proba_M',$proba_M);
# 	$match->set_attribute('proba_B',$proba_B);
# 	if ($return_fields{pval}) {
# 	  $match->set_attribute('pval',$pval);
# 	  $match->set_attribute('ln_pval',$ln_pval);
# 	  $match->set_attribute('sig',$sig);
# 	}
# 	$match->set_attribute('normw',$normw) if ($return_fields{normw});
# 	#    if (($calc_fields{rank}) || ($calc_fields{pval})){
# 	# If the hits have to be ranked, store them rather than printing them immediately
# 	push @matches , $match;
# 	push @{$matches_per_matrix{$matrix->get_attribute('name')}} , $match;
# 	push @{$matches_per_seq{$seq_id}} , $match;
#       }
#       #      push @{$sequence_scores->{$seq_id}->matches} , $match if ($return_fields{seq_scores});
#       #    } else {
#       #      &print_match($match) if ($main::return_fields{sites});
#       #    }
#     }
# }

