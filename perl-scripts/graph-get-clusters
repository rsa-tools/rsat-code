#!/usr/bin/perl -w
############################################################
#
# $Id: graph-get-clusters,v 1.9 2007/04/24 07:38:03 rsat Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################

## use strict;

=pod

=head1 NAME

graph-get-clusters

=head1 DESCRIPTION

Extract from a graph a subgraph specified by a set of node
clusters. Return the nodes belonging to the clusters + the
intra-cluster arcs, and ignore the inter-cluster arcs.

The program also allows to extract the inducted graph from a list of seed nodes.

=head1 AUTHORS

=over

=item jvanheld@scmbb.ulb.ac.be

=item sylvain@scmbb.ulb.ac.be

=head1 CATEGORY

graph analysis

=head1 USAGE

graph-get-clusters [-i graph_file] -clusters cluster_file [-o outputfile] [-inducted] [-v #] [...]

=head1 INPUT FORMAT

=head2 Graph format

See I<convert-graph> for a description of the supported input graph
formats. Default format for the input graph: tab.

=head2 Cluster format

Without -inducted option (default) : a two-column file with column corresponding respectively to the node name and to the cluster name.
With -inducted option : a one column file specifying to nodes from which the output graph will be inducted.

=head1 OUTPUT FORMAT

The default output file is a graph in GML format. 
However, other output formats are available using the -out_format option.

See I<convert-graph> for a description of the supported output graph
formats. Note that it is not recommended to use the tab-delimted
format for the output graph, because orphan nodes (nodes without any
arc) would not be displayed (the tab format is restricted to a
description of the arcs). 

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require RSAT::Graph2;


################################################################
## Main package
package main;
{

  ################################################################
  ## Palette for the cluster-specific node colors
  my @cluster_colors_dot = qw(blue 
			      green
			      orange
			      cyan
			      darkviolet
			      red
			      gray
			      magenta
			      black
			      darkgreen
			      darkblue
			      violet
			      darkgray);
  my @cluster_colors_gml = ('#0000FF', ## Blue
			    '#FF0000', ## Red
			    '#FF00FF', ## Magenta
			    '#004488', ## 
			    '#00FF00',
			    '#888888',
			    '#FF0088',
			    '#000000',
			    '#880000',
			    '#000088',
			    '#8800FF',
			    '#444444');


    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();

    ################################################################
    ## Initialize the input graph
    $graph = new RSAT::Graph2();
    $graph->set_attribute("label", "input graph");

    ## Columns of the tab-delimited graph file
    local $source_col = 1;
    local $target_col = 2;
    local $weight_col = 0;



    ################################################################
    ## Initialize the output graph (cluster graph)
    my $cluster_graph = new RSAT::Graph2();
    $cluster_graph->set_attribute("label", "cluster_graph");
    my @cluster_graph_array = ();
    my $cluster_graph_array_cpt = 0;
    
    ## Input formats
    local $input_format = "tab";
    %supported_input_format =(
	tab=>1,
	gml=>1
    );
    $supported_input_formats = join (",", keys %supported_input_format);
    local $source_col = 1;
    local $target_col = 2;
    local $weight_col = 0;
    ## Output formats
    %supported_output_format =(
			       dot=>1,
			       gml=>1,
			       tab=>1

    );
    $supported_output_formats = join (",", keys %supported_output_format);
    local $output_format = "gml";

    %found_nodes = (); ## Index the names of identified nodes
    %unknown_nodes = (); ## Index the names of unknown nodes

    %main::infile = ();
    %main::outfile = ();
    $main::verbose = 0;
    $main::out = STDOUT;
    $distinct = 0;
    $inducted = 0;
    my %duplicated_nodes;
    my @arcs_clusters;
    
    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values
    @cluster_colors = ();
    if ($output_format eq "dot") {
      @cluster_colors = @cluster_colors_dot;
    } else {
      @cluster_colors = @cluster_colors_gml;
    }


    ################################################################
    ## Open output stream
    $main::out = &OpenOutputFile($main::outfile{output});

    ################################################################
    ## Read input graph
    $graph->graph_from_text($input_format,$main::infile{graph}, $source_col, $target_col, $weight_col);

    ################################################################
    ## Read and add the class specification to each node
    $graph->load_classes($main::infile{clusters}, $inducted);

    ################################################################
    ## Extract the intra-cluster subgraphs
    &RSAT::message::TimeWarn("Identifying cluster nodes in the graph") if ($main::verbose >= 2);
    my @cluster_list = $graph->get_attribute("cluster_list");
    $cluster_nb = scalar @cluster_list;
    my @arcs = $graph->get_attribute("arcs");
    my %nodes_name_id = $graph->get_attribute("nodes_name_id");
    my %nodes_id_name = $graph->get_attribute("nodes_id_name");
    my %nodes_color = $graph->get_attribute("nodes_color");
    my %edge_cluster = ();
    my %cluster_color = ();
    my $arc_nb = scalar(@arcs);
    
    for (my $i = 0; $i < scalar(@arcs); $i++) {
      if (($main::verbose >= 2) && ($i%10000==0)) {
	&RSAT::message::psWarn("Treated", $i."/".$arc_nb, "arcs");
      }
      my $source_node = $arcs[$i][0];
      my $target_node = $arcs[$i][1];
      my $source_node_id = $nodes_name_id{$source_node};
      my $target_node_id = $nodes_name_id{$target_node};
      my @source_clusters = $graph->get_nodes_clusters($source_node);
      my @target_clusters = $graph->get_nodes_clusters($target_node);
      
      
      foreach my $scluster (@source_clusters) {
        foreach my $tcluster (@target_clusters) {
          if ($scluster eq $tcluster) {
            if ($weight_col <= 0) {
	      $label =  join("_", $source_node, $target_node, $scluster);
	    } else {
	      $label = $arcs[$i][2];
	    }
	    my $scolor = $nodes_color{$source_node_id};
	    my $tcolor = $nodes_color{$target_node_id};
	    my $arc_color = $cluster_color{$scluster};
	    if (!defined($arc_color)) {
	      $arc_color = $cluster_colors[scalar(keys(%cluster_color)) % scalar(@cluster_colors)];
	      $cluster_color{$scluster} = $arc_color;
	    } 
	    if ($distinct) {
	      my $arc_key = $source_node."_arc_".$target_node;
	      my $edge_other_cluster = $edge_cluster{$arc_key};
	      if (defined($edge_other_cluster) && $edge_other_cluster ne $scluster) {
	        if (!defined($duplicated_nodes{$source_node})) {
	          $duplicated_nodes{$source_node} = 2;
	        }
	        $source_node = $source_node."_".$duplicated_nodes{$source_node};
	        $duplicated_nodes{$source_node}++;
	        
	        if (!defined($duplicated_nodes{$target_node})) {
	          $duplicated_nodes{$target_node} = 2;
	        }
	        $target_node = $target_node."_".$duplicated_nodes{$target_node};
	        $duplicated_nodes{$target_node}++;
	      } else {
	        $edge_cluster{$arc_key} = $scluster;
	      }
	    }
            $cluster_graph_array[$cluster_graph_array_cpt][0] = $source_node;
            $cluster_graph_array[$cluster_graph_array_cpt][1] = $target_node;
            $cluster_graph_array[$cluster_graph_array_cpt][2] = $label;
            $cluster_graph_array[$cluster_graph_array_cpt][3] = $scolor;
            $cluster_graph_array[$cluster_graph_array_cpt][4] = $tcolor;
            $cluster_graph_array[$cluster_graph_array_cpt][5] = $arc_color;
            push @{$arcs_clusters[$cluster_graph_array_cpt]}, $scluster;
            $cluster_graph_array_cpt++;
          }
        }
      }
    }
    $cluster_graph->load_from_array(@cluster_graph_array);
    $cluster_graph->set_array_attribute("arcs_attribute", @arcs_clusters);
    
    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);

    ## Print the output graph
    print $out $cluster_graph->to_text($output_format);



    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});

    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Graph file
=pod

=item B<-i graphfile>

If no graph file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	  $main::infile{graph} = shift(@arguments);

	    ## Source column
=pod

=item B<-scol>

Source column. Column containing the source nodes in the tab-delimited
graph file.  

=cut
	} elsif ($arg eq "-scol") {
	    $source_col = shift (@arguments);
	    unless (&IsNatural($source_col) && ($source_col > 0)) {
		&RSAT::error::FatalError(join("\t", $source_col, "Invalid value for the source column. Must be a strictly positive natural number"));
	    }

	    ## Target column
=pod

=item B<-tcol>

Target column. Column containing the target nodes in the tab-delimited
graph file.

=cut
	} elsif ($arg eq "-tcol") {
	    $target_col = shift (@arguments);
	    unless (&IsNatural($target_col) && ($target_col > 0)) {
		&RSAT::error::FatalError(join("\t", $target_col, "Invalid value for the target column. Must be a strictly positive natural number"));
	    }

	    ## Weight column
=pod

=item B<-wcol>

Weight column. Column containing the weight of the nodes in the tab-delimited
graph file. 

By specifying the weight of the node, the label of the arcs will not be 
changed from arc_label to arc_label_cluster_name. As a consequence, if you don't use the -distinct option, arcs belonging to more than one
cluster will be duplicated but will present the same label. Some visualization program like Cytoscape
cannot deal with such arcs. You should maybe use yEd for a more exact visualization of the extracted clusters.

=cut
	} elsif ($arg eq "-wcol") {
	    $weight_col = shift (@arguments);
	    unless (&IsNatural($weight_col) && ($weight_col > 0)) {
		&RSAT::error::FatalError(join("\t", $weight_col, "Invalid value for the weight column. Must be a strictly positive natural number"));
	    }



=pod

=item B<-clusters cluster_file>

Cluster file. The seed file specifies a list of node clusters.

=cut
	} elsif ($arg eq "-clusters") {
	    $main::infile{clusters} = shift(@arguments);
=pod

=item B<-in_format input_format>

Input format. Supported: tab, gml

=cut
	} elsif ($arg eq "-in_format") {
	    $input_format = shift(@arguments);
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supported: $supported_input_formats")
		unless ($supported_input_format{$input_format});

=pod

=item B<-distinct>

As some nodes may belong to more than one group, using this option will duplicate the nodes belonging to more
than one group.

=cut
	
	} elsif ($arg eq "-distinct") {
	    $distinct = 1;
=pod

=item B<-inducted>

Using this option, only the first column of the cluster file will be taken into account. The output graph will
thus consist in the graph inducted by all nodes of the first column.

=cut
	
	} elsif ($arg eq "-inducted") {
	    $inducted = 1;	    
	    
	    
## Output file

=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);


	    ### Output format  
=cut

=item B<-out_format output_format>

See convert-graph for a list of supported output formats.

=cut 
	} elsif ($arg eq "-out_format") {
	    $output_format = shift(@arguments);
	    &RSAT::error::FatalError("$output_format\tInvalid output format. Supported: $supported_output_formats")
		unless ($supported_output_format{$output_format});


	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    my $this_out = $out;
    if ($output_format eq "gml") {
      $this_out = STDOUT;
    }
    print $this_out "; graph-get-clusters ";
    &PrintArguments($this_out);
    if (defined(%main::infile)) {
	print $this_out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $this_out ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print $this_out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $this_out ";\t$key\t$value\n";
	}
    }

    ## Report graph size
    my ($nodes, $arcs) = $graph->get_size();
    print $this_out "; Graph size\n";
    print $this_out ";\tnodes\t",$nodes,"\n";
    print $this_out ";\tarcs\t",$arcs,"\n";

    ## Report seed nodes
    print $this_out "; Clusters\t", $cluster_nb,"\n";
    print $this_out ";\tidentified nodes\t",scalar(keys(%found_nodes)),"\n";
    my @unknown_nodes = keys(%unknown_nodes);
    my $unknown_node_nb = scalar(@unknown_nodes);
    if ($unknown_node_nb > 0) {
      print $this_out ";\tunknown nodes\t",,"\n";
      foreach my $name (@unknown_nodes) {
	print $this_out join ("\t", ";\t", "unknown", $name), "\n";
      }
    }
    if ($main::verbose >= 1) {
      my $done_time = &AlphaDate();
      print $this_out "; Job started $start_time";
      print $this_out "; Job done    $done_time\n";
    }
    if ($this_out ne STDOUT) {
      if ($main::verbose >= 1) {
        my $done_time = &AlphaDate();
        print STDOUT "; Job started\t$start_time";
        print STDOUT "; Job done\t$done_time\n";
      }
    }
}


__END__

=pod

=head1 SEE ALSO

=over

=item I<graph-neighbours>

=item I<convert-graph>


=item I<compare-classes>

=item I<convert-classes>

=back

=cut
