#!/usr/bin/perl -w
############################################################
#
# $Id: variation-info,v 1.0 2013/10/03 17:24:24 amedina Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

variation-info

=head1 VERSION

$program_version

=head1 DESCRIPTION

Taking as input variation IDs (rs numbers) or regions in a given genome I<variation-info> 
will retrieve the varians information varBed format.

=head1 AUTHORS

=over

=item B<Alejandra Medina Rivera> <amedina@lcg.unam.mx>

=item B<Jacques van Helden> <Jacques.van-Helden\@univ-amu.fr>

=back 

=head1 CATEGORY

=over

=item util

=back

=head1 USAGE

variation-info [-i inputfile] [-o outputfile] [-v #] [-format variatio_format]
    [- col ID_column ] [-mml #] [-o output_file] [...]

=head1 INPUT FORMAT
=head2 Genomic coordinate file

The option I<-i> allows to specify a genomic coordinate file in bed
format. The program only takes into account the 3 first columns of the
bed file, which specify the genomic coordinates.

B<Note> (from Jacques van Helden): the UCSC genome browser adopts a
somewhat inconsistent convention for start and end coordinates: the
start position is zero-based (first nucleotide of a
chromosome/scaffold has coordinate 0), but the end position is
considered not included in the selection. This is equivalent to have a
zero-based coordinate for the start, and a 1-base coordinate for the
end.

=head2 Example of bed file

 chr1	3473041	3473370
 chr1	4380371	4380650
 chr1	4845581	4845781
 chr1	4845801	4846260

The definition of the BED format is provided on the UCSC Genome
Browser web site (http://genome.ucsc.edu/FAQ/FAQformat#format1).

This program only takes into account the 3 first columns, which
specify the genomic coordinates.

=over

=item 1. chrom

The name of the chromosome (e.g. chr3, chrY, chr2_random) or scaffold
(e.g. scaffold10671).

=item 2. chromStart

The starting position of the feature in the chromosome or
scaffold. For RSAT programs, the first base in a chromosome is
numbered 1 (this differs from the UCSC-specific zero-based notation
for the start).

B<Note> from Jacques van Helden: the UCSC genome browser adopts a
somewhat inconsistent convention for start and end coordinates: the
start position is zero-based (first nucleotide of a
chromosome/scaffold has coordinate 0), and the end position is
considered not included in the selection. This is equivalent to have a
zero-based coordinate for the start, and a 1-base coordinate for the
end. We find this representation completely counter-intuitive, and we
herefore decided to adopt a "normal" convention, where:

=over

=item start and end position represent the first and last positions
I<included> in the region of interest.

=item start and end positions are provided in one-based notation
(first base of a chromosome or contig has coordinate 1).

=back

=item 3. chromEnd

The ending position of the feature in the chromosome or scaffold.

=back

=head2 Variation file

See I<download-ensembl-variation> output format.

=head2 Variation ID list

A tab delimited file with id of variation in column.

=head1 OUTPUT FORMAT

varBed format is a tab delimited file that facilitates access to relevant variant 
information. The file includes the following columns:

=over

=item 1) chr

Chromosome number (without "chr")

=item 2) start 

 Possition of the variations

=item 3) end

Possition of the variation 

=item 4) strand

strand were the variation was annotates

=item 5) id

variant ID, rs number

=item 6) ref

Reference allele

=item 7) alt

Alternative allele

=item 8) so_term validate

validation of the variant, 1 if it had evidence

=item 9) minor_allele_freq

Frequency of the alternative allele

=item 10) is_supvar

1 if this variant was constructed using overlaped variants

=item 11) in_supvar

1 if this this variant is overlaping with other anntotated variants

=back

=head1 SEE ALSO

=head2 download-ensembl-genome

Installe organims from ensembl genomes.

=head2 download-ensembl-variations

Get variation coordiantes from ensembl.
Variants information obtained with this tool are retrived by
I<variation-info>.

=head2 convert-variations

Convert between diferent variation data file types.
I<variation-info> retrieves variants in varBed format, 
<convert-variations> can be used to convert to vcf anf gvf formats.

=head2 retrieve-variations-seq

Given a set of regions, varian IDs (rsNumber) or variants in varBed format
<retrieve-variation-seq> will retrive the corresponding genomic 
sequence sorounding the genetic variants.

=head2 variation-scan

Scan variation sequences with one or several position-specific scoring
matrices.


=head1 WISH LIST

=over

=item B<wish 1>

=back

=cut


BEGIN {
  if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
  }
}
require "RSA.lib";
require "RSAT_to_ensembl.lib.pl";



################################################################
## Main package
package main;
{

  ################################################################
  ## Initialise parameters
  our $start_time = &RSAT::util::StartScript();
  our $program_version = do { my @r = (q$Revision: 1.00 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  #    $program_version = "0.00";

  our %infile = ();
  our %outfile = ();

  our $verbose = 0;
  our $in = STDIN;
  our $out = STDOUT;
  
  our $species = '';
  our $ensembl_version = "";
  our $assembly_version = "";

  our $col = 1;
  our $validate = 0 ;

  ## Define supported output formats
  our @supported_input_formats = qw (varBed id bed);
  our $supported_input_formats = join ",", @supported_input_formats;
  our %supported_input_format = ();
  foreach my $format (@supported_input_formats) {
      $supported_input_format{$format} = 1;
  }
  our $format = "";

  
  our $total_nb_variation = 0;
  our $total_nb_variant = 0;

  ################################################################
  ## Read argument values
  &ReadArguments();

  our $genomes_dir = &Get_genomes_dir();

  ################################################################
  ## Check argument values

  ## Species and assembly or ensembl version have to be specified
  &RSAT::error::FatalError("No species specified. Use -species") unless ($species);
  &RSAT::error::FatalError("No assembly and ensembl version specified. Use at least one of these options: -e_version -a_version") unless ($ensembl_version || $assembly_version);
  
  ## Check input format and file existance
  if ($main::infile{'input'}) {
      &RSAT::error::FatalError("No input format specified. Use -format") unless ($format);
      &RSAT::error::FatalError("Input file $main::infile{'input'} not found") unless  (-f $main::infile{'input'});
  }
  
  ## Check species genome and variations directories
  my $genome_dir = &Get_genome_dir($species, $assembly_version, $ensembl_version,$species_suffix);
  my $variation_dir = &Get_variation_dir($species, $assembly_version, $ensembl_version, $species_suffix);
  
  &RSAT::error::FatalError("Genome directory", $genome_dir, "does not exist. Use download-ensembl-genome before retrieve-variation-seq.") unless (-d $genome_dir);
  &RSAT::error::FatalError("Variation directory", $variation_dir, "does not exist. Use download-ensembl-variation before retrieve-variation-seq.") unless (-d $variation_dir);

  ## Check if genome sequence files are not missing
  my %chr_file = &Get_file_seq_name($genome_dir);
  
  foreach my $file (keys(%chr_file)) {
      my $raw_seq_file=$genome_dir."/".$chr_file{$file};
      unless (-f $raw_seq_file) {
	  &RSAT::error::FatalError($raw_seq_file," is missing.");
      }
  }
  
  ################################################################
  ## Print verbose
  &Verbose() if ($main::verbose >= 1);
  
  
  ################################################################
  ## Open output stream
  $out = &OpenOutputFile($outfile{output});

  ## Print varBed header
  print $out join("\t","#chr",
		  "start",
		  "end",
		  "strand",
		  "id",
		  "ref",
		  "alt",
		  "so_term",
		  "validate",
		  "minor_allele_freq",
		  "is_supvar",
		  "in_supvar\n");

  ################################################################
  ## Get the list of variation files installed in the RSAT data
  ## directory.
  my @variation_files = ();

  #########
  ## AMR NOTE: I'm having a lot of problems with the glob function
  ## and haven't been able to figure them out.
  ## I'll change back this part of the code as soon as I get it to
  ## work. This code is a patch

  my $vart_files=`ls $variation_dir/*.varBed`;
  @variation_files= split ("\n",$vart_files);
  
  
  ## print join("+",@variation_files);
  ## die "BOOM";
  ## foreach ( glob ( $variation_dir."*.varBed") ) {
  ##  push (@variation_files,$_) unless (/Failed/);
  ## }
  
  
  ################################################################
  ## Read infile containing variation IDs
  if ($format eq "id") {
      &RSAT::message::TimeWarn("Retrieving variations from ID(s)") if ($main::verbose >= 2);
      
      
      my %variation_id = ();
      
      ## Get ID list
      if ($main::infile{'input'}) {
	  ($main::in) = &OpenInputFile($main::infile{'input'});
      }

      ## Get SNP ids from the input list 
      while (<$main::in>) {
	  next if (/^#/);
	  next if (/^;/);
	  next unless (/\S/);
	  chomp();
	  my @fields = split("\t");
	  my $id =  $fields[$col-1]; ## Select the ID from the user-specified column
	  
	  ## Check if the ID has already been found previously if the
	  ## file. If yes ignore it, if not add it to the list.
	  unless (defined($variation_id{$id})) {
	      push @variation_ids, $id;
	      $variation_id{$id} = 1; ## Index the curent ID to remove potential duplicates
	  }
	  
      }
      &RSAT::message::TimeWarn("Number of variations to find:", scalar(@variation_ids) ) if ($main::verbose >= 2);
      
      ## Try to idenfity the variations in each chromosome separately.
      ## Note: there is a tradeoff between different efficiency issues, since for Human genome there are 
      ## ALE'S NOTE: THIS NOTE IS INCOMPLETE
      
      ## Grep each variation file to collect the selected IDs
      foreach my $file_name (@variation_files) {
	  my @variations_to_find = sort keys (%variation_id);
	  &RSAT::message::Warning("Starting to grep variation file", $file_name) if ($main::verbose >= 2);
	  &RSAT::message::Warning("Variation IDs remaining to be found", scalar(@variations_to_find)) if ($main::verbose >= 2);
	  
	  last if (scalar(@variations_to_find) == 0);      
	  
	  ## Create a regular expression to select the rows containing
	  ## query IDs with grep. Only search the variations that have not
	  ## yet been identified.
	  my $grep_expression = join('\|',@variations_to_find); ## 
	  my $grep_cmd = "grep '".$grep_expression."' ".$file_name;
	  &RSAT::message::Warning("Running grep command", $grep_cmd) if ($main::verbose >= 3);
	  
	  my @result = qx{$grep_cmd};
	  
	  my $i = 0;
	  foreach (@result) {
	      chomp();
	      my @fields = split("\t");
	      
	      ## Skip super-variation 
	      my $is_super = $fields[10];
	      ## Ale's note: colum number changed after adding minor allele frequency. JvH note: we should later check if we really want to maintain these super-variations
	      next if ($is_super); 
	      
	      ## Check if the variation ID is part of the queries
	      my $current_id = $fields[4];
	      next unless ($variation_id{$current_id});
	      
	      
	      ## Remove found variation from the list of variations to be found
	      delete($variation_id{$fields[4]});       	
	      
	      ## Remove info about in_super_variation  ## Ale's note: colum number changed after adding minor allele frequency
	      $fields[11] = 0;
	      
	      ## Report variation information in outfile
	      print $out join("\t",@fields),"\n"; 
	      $i++;
	  }
	  
	  
	  $file_name = &RSAT::util::hide_RSAT_path($file_name);
	  &RSAT::message::TimeWarn("\t$i variation(s) found in file", $file_name, "Remaining", scalar(keys(%variation_id) )) if ($main::verbose >= 2);
      }
      close $out;
      
      ## Report not found variations
      my @not_found = sort(@variation_ids);
      my $not_found_nb = scalar(@not_found);
      if ($not_found_nb > 0) {
	  &RSAT::message::Warning("; Non-identified variations: ",$not_found_nb) if ($main::verbose >= 2);
	  my $not_found_msg .= "; Note: some variations may have failed to pass Ensembl or RSAT quality check\n";
	  
	  foreach my $id (@not_found) {
	      $not_found_msg .= ";\tmissing\t".$id."\n";
	  }
	  print $out $not_found_msg;
      }
      
      $main::infile{'input_variation'} = $main::outfile{'variation_rsat'};
  }
  
  ################################################################
  ## Get variation from coordinates

  elsif ($format eq "bed") {
    &RSAT::message::TimeWarn("Processing bed file",$main::infile{'input'}) if ($main::verbose >= 2);
    my %chr_coord = ();

    if ($main::infile{'input'}) {
      ($main::in) = &OpenInputFile($main::infile{'input'});
    }

    ## Get coordinates from bed file and store them in a hash %chr_coord
    while (<$main::in>) {
	
	next if (/^#/);
	next if (/^;/);
	#next unless (/\t/);
	## if user input a file that is space separated change it to tab
	$_=~s/ +/\t/g;
	chomp();
	
	my ($chr,$left,$right,$strand)= split("\t");
	
	$chr =~ s/chr//g;
	$chr = "MT" if ($chr eq "M"); ## Match naming format for the methocondrial chromosome
	$left ++;
	
	if ($left > $right) {
	    &RSAT::message::Warning("Skipping line : ", $_, "Left (".$left.") > right (".$right.").") if ($main::verbose >= 2);
	    next;
	}
	
	unless ($chr_file{$chr}) {
	    &RSAT::message::Warning("Skipping line : ", $_, "No variation file for chromosome $chr.") if ($main::verbose >= 2);
	    next;
	}
	
	$chr_coord{$chr}{$left} = $right;
    }
    
    ## Retrieve variation
    &RSAT::message::TimeWarn("Retrieve variations from coordinate") if ($main::verbose >= 2);
    
    ## For each chromosome reported in the bed file
    ## ALE NOTE: This process depends completely on the RSAT variation files being sorted
    foreach $chr (keys(%chr_coord)) {
	my @lefts = sort {$a <=> $b} (keys(%{$chr_coord{$chr}})); ## sort coordinates per chromosome based on left side 
	my $nb_coord = scalar(@lefts);
	my $i = 0;
	my $nb_variation = 0;
	my ($var_file) = &OpenInputFile($variation_dir."/".$chr.".varBed"); ## Variation file in RSAT corresponding to the chromosome
	
	my $left = $lefts[$i];
	my $right = $chr_coord{$chr}{$left};
	
	while (<$var_file>) {  ## Open RSAT variation file for the current chromosome
	    next if (/^#/);
	    next if (/^;/);
	    next unless (/\t/);
	    my @fields = split("\t"); ## One variation 
	    
	    if ($fields[1] <= $right && $fields[2] >= $left) { ## If variant is inside the coordinate print variant in variation file
          $nb_variation++;
          print $out $_ ;
	    } elsif ($fields[2] > $right) { ## Get the next coordinate if the current variant is out of bounds for the current coordinate
		$i++; 
		last if ($i >= $nb_coord);
		$left = $lefts[$i];
		$right = $chr_coord{$chr}{$left};
	    }
	    
      }
    &RSAT::message::TimeWarn($nb_variation,"variation found on peaks of chromosome",$chr) if ($main::verbose >= 2);

    }
    close $out;
    $main::infile{'input_variation'} = $main::outfile{'variation_rsat'};
  }
  
  ################################################################
  ## Report execution time and close output stream
  &close_and_quit();
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Close output file and quit
sub close_and_quit {

  ## Report execution time
  my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts
  print $main::out $exec_time if ($main::verbose >= 1); ## only report exec time if verbosity is specified

  ## Close output file
  if ($outfile{output}) {
    close $main::out;
    &RSAT::message::TimeWarn("Output file", $outfile{output}) if ($main::verbose >= 2);
  }

  ## CLOSE OTHER FILES HERE IF REQUIRED

  exit(0);
}


################################################################
## Display full help message 
sub PrintHelp {
  system "pod2text -c $0";
  exit()
}

################################################################
## Display short help message
sub PrintOptions {
  &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);


=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
      } else {
	$main::verbose = 1;
      }


=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();


=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();


=pod

=item B<-species species_name>

Species name. This name must correspond to the species of the
variation/bed/id file if provided.

=cut
    } elsif ($arg eq "-species") {
      $main::species = lc(shift(@arguments));

=pod

=item B<-species_suffix>

Species name. This name must correspond to the species of the
variation/bed/id file if provided.

=cut
    } elsif ($arg eq "-species_suffix") {
      $main::species_suffix = lc(shift(@arguments));

=pod

=item B<-e_version #>

The version of ensembl database (e.g. 72).

Note: each Ensembl version contains a specific assembly version for
each species. When the option -e_version is used, the option
-a_version should thus in principle not be used.

=cut
    } elsif ($arg eq "-e_version") {
      $main::ensembl_version = shift(@arguments);

=pod

=item B<-a_version #>

Assembly version (e.g. GRCh37 for the assembly 37 of the Human genome).

Note: genome assemblies can cover several successive ensemble
versions. In case of ambiguity, the latest corresponding ensembl
version is used.

=cut
    } elsif ($arg eq "-a_version") {
      $main::assembly_version = shift(@arguments);

=pod

=item B<-i inputfile>

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
    } elsif ($arg eq "-i") {
      $main::infile{input} = shift(@arguments);

=pod

=item B<-format variation_format>

Format of the input file

Supported formats: 

=over

=item I<varBed>

Format of variation files used by all RSAT scripts.

=item I<id>

tab-delimited file with all variation IDs in a given column, which can
be specified by the option I<-col>.

=item I<bed>

General format for the description of genomic features
(see https://genome.ucsc.edu/FAQ/FAQformat.html#format1).

=back 

=cut
    } elsif ($arg eq "-format") {
      $main::format = shift(@arguments);
      unless ($supported_input_format{$main::format}) {
         &RSAT::error::FatalError($format, "Invalid input format. Supported: ". $supported_input_formats);
      }

=pod

=item B<-col #>

Column containing the variation IDs with the input format "id".

Default : 1

=cut
    } elsif ($arg eq "-col") {
      if (&IsNatural($arguments[0])) {
        $main::col = shift(@arguments);
      } else {
        &RSAT::error::FatalError("-col argument : ",shift(@arguments)," is not natual");
      }

=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
    } elsif ($arg eq "-o") {
      $outfile{output} = shift(@arguments);

    } else {
      &FatalError(join("\t", "Invalid option", $arg));

    }
  }

=pod

=back

=cut

}

################################################################
## Verbose message
sub Verbose {
  print $out "; template ";
  &PrintArguments($out);
  printf $out "; %-22s\t%s\n", "Program version", $program_version;
  if (%main::infile) {
    print $out "; Input files\n";
    while (my ($key,$value) = each %main::infile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }
  if (%main::outfile) {
    print $out "; Output files\n";
    while (my ($key,$value) = each %main::outfile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }
}


__END__
