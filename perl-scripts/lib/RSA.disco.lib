#!/usr/bin/perl
################################################################
## Libraries for shared tasks between pattern discovery programs
## (oligo-analysis and dyad-analysis)

package main;

## Supported thresholds
%lth = (); # lower threshold values
%uth = (); # upper threshold values
@supported_thresholds = qw(
			   occ
			   occ_P
			   occ_E
			   occ_sig
			   observed_freq
			   exp_freq
			   zscore
			   mseq
			   ms_P
			   ms_E
			   ms_sig
			   ratio
			   rank
			 );
#			   likelihood

$supported_thresholds = join ",", @supported_thresholds;
%supported_threshold = ();
foreach my $thr (@supported_thresholds) {
    $supported_threshold{$thr} = 1;
}

## Print threshold values for verbosity
sub PrintThresholdValues {
    my %th = (%lth, %uth);
    my @keys = keys %th;
    my $message = "";
    if (scalar(@keys > 0)) {
	$message .= sprintf "; Threshold values\n";
	$message .= sprintf  ";\t%-15s\t%s\t%s\n", "Parameter", "Lower", "Upper";
	foreach my $key (@keys) {
	    my $lth = "none";
	    my $uth = "none";
	    if (defined($lth{$key})) {
		$lth = $lth{$key};
	    }
	    if (defined($uth{$key})) {
		$uth = $uth{$key};
	    }
	    $message .= sprintf  ";\t%-15s\t%s\t%s\n", $key, $lth, $uth;
	}
    }
    return $message;
}

## Specify threshold options for oligo-analysis and dyad-analysis
sub ThresholdOptions {
    my $threshold_options = "";
    foreach my $key (keys %lth) {
	$threshold_options .= join(" ", " -lth", $key, $lth{$key});
	&RSAT::message::Debug("Lower threshold", $key, $lth{$key}) if ($main::verbose >= 3);
    }
    foreach my $key (keys %uth) {
	$threshold_options .= join(" ", " -uth", $key, $uth{$key});
	&RSAT::message::Debug("Upper threshold", $key, $uth{$key}) if ($main::verbose >= 3);
    }
    return ($threshold_options);
}

################################################################
## Indicate threshold options in the suffix
sub ThresholdSuffix {
    my $threshold_suffix = "";
    foreach my $key (sort keys %lth) {
	$threshold_suffix .= "_lth_".$key.$lth{$key};
    }
    foreach my $key (sort keys %uth) {
	$threshold_suffix .= "_uth_".$key.$uth{$key};
    }
    return ($threshold_suffix);
}

################################################################
## Check thresholds on all parameters for a given parameter
sub CheckThresholds {
  my ($key) = @_;
  &CheckLowerThresholds($key);
  &CheckUpperThresholds($key);
}

################################################################
## Check lower thresholds on all patterns for a given parameter
sub CheckLowerThresholds {
  my ($key) = @_;
  if (defined($main::lth{$key})) {
    &RSAT::message::TimeWarn("Lower threshold on $key\t$main::lth{$key}") if ($main::verbose >= 3);
    foreach $pattern_seq (keys %main::patterns) {
      if ($main::patterns{$pattern_seq}->{$key} < $main::lth{$key}) {
	#	      &RSAT::message::Debug("Lower threshold", "deleting pattern", $pattern_seq, $key, $main::patterns{$pattern_seq}->{$key}, $main::lth{$key}) if ($main::verbose >= 0);
	delete $main::patterns{$pattern_seq};
      }
    }
  }
}

################################################################
## Check upper thresholds on all patterns for a given parameter
sub CheckUpperThresholds {
  my ($key) = @_;
  if (defined($main::uth{$key})) {
    &RSAT::message::TimeWarn("Upper threshold on $key\t$main::uth{$key}") if ($main::verbose >= 3);
    foreach $pattern_seq (keys %main::patterns) {
      if ($main::patterns{$pattern_seq}->{$key} > $main::uth{$key}) {
	#	      &RSAT::message::Debug("Upper threshold", "deleting pattern", $pattern_seq, $key, $main::patterns{$pattern_seq}->{$key}, $main::lth{$key}) if ($main::verbose >= 0);
	delete $main::patterns{$pattern_seq};
      }
    }
  }
}


################################################################
#### check threshold on some parameter for one pattern
sub CheckPatternThresholds {
  my ($key, $pattern_seq) = @_;

  ## Lower threshold
  if (defined($main::lth{$key})) {
    &RSAT::message::TimeWarn("Lower threshold on $key\t$main::lth{$key}") if ($main::verbose >= 4);
    if ($main::patterns{$pattern_seq}->{$key} < $main::lth{$key}) {
      delete $main::patterns{$pattern_seq};
      return();
    }
  }

  ## Upper threshold
  if (defined($main::uth{$key})) {
    &RSAT::message::TimeWarn("Upper threshold on $key\t$main::uth{$key}") if ($main::verbose >= 4);
    if ($main::patterns{$pattern_seq}->{$key} > $main::uth{$key}) {
      delete $main::patterns{$pattern_seq};
    }  
  }
}


################################################################
### Corrections for multi-testing
sub MultiTestCorrections {
    my ($nb_tested_patterns, %patterns) = @_;
    &RSAT::message::TimeWarn(join ("\t", "Correcting for multiple testing", $nb_tested_patterns)) if ($main::verbose >= 2);
    foreach my $pattern_seq (keys %patterns) {
	if (&IsReal ($patterns{$pattern_seq}->{occ_P})) {
	    $patterns{$pattern_seq}->{occ_E} =  $patterns{$pattern_seq}->{occ_P}*$nb_tested_patterns;
	    if ($patterns{$pattern_seq}->{occ_E} > 0) {
		$patterns{$pattern_seq}->{occ_sig} =  -log($patterns{$pattern_seq}->{occ_E})/log(10);
	    } else {
		$patterns{$pattern_seq}->{occ_sig} =  999;
	    }
	} else {
	    $patterns{$pattern_seq}->{occ_E} = "NA";
	    $patterns{$pattern_seq}->{occ_sig} = "NA";
	}
# 	&RSAT::message::Debug("Calculating E-value",  
# 			      $pattern_seq,
# 			      $patterns{$pattern_seq}->{occ},
# 			      $patterns{$pattern_seq}->{occ_P},
# 			      $nb_tested_patterns,
# 			      $patterns{$pattern_seq}->{occ_E},
# 			      $patterns{$pattern_seq}->{occ_sig},
# 			     ) if ($main::verbose >= 10);
     }
}

################################################################
#### when grouping occurrences with their reverse complement, 
#### only retain one of each pair. 
sub GroupRC {
  &RSAT::message::TimeWarn("Grouping pairs of reverse complements\n") if ($main::verbose >= 2);
  foreach $pattern_seq (keys %patterns) {
    $rc_pattern_seq = &SmartRC($pattern_seq);
    #	&RSAT::message::Debug("Grouping reverse complements", $pattern_seq, $rc_pattern_seq) if ($main::verbose >= 4);
    if ($rc_pattern_seq gt $pattern_seq) { ### only suppress one oligo from the pair
      delete $patterns{$rc_pattern_seq};
    }
  }
}


################################################################
## Do the opposite as GroupRC: starting from the grouped RC, re-create
## one pattern for the RC of each pattern
sub UngroupRC {
    &RSAT::message::TimeWarn("; Reporting both elements of reverse complements pairs\n") if ($main::verbose >= 2);
    foreach $pattern_seq (keys %patterns) {
	$rc_pattern_seq = &SmartRC($pattern_seq);
	warn ("; Ungrouping reverse complements\t", $pattern_seq, "\t", $rc_pattern_seq, "\n") if ($main::verbose >= 4);
	if ($rc_pattern_seq gt $pattern_seq) { ### only suppress one oligo from the pair
	    $patterns{$rc_pattern_seq} = $patterns{$pattern_seq} ;
	}
    }
}

################################################################
#### Calculate observed/expected ratio
sub CalcRatio {
    if ($return{'freq'}) {
	foreach $pattern_seq (sort keys %patterns) {
	    if ($patterns{$pattern_seq}->{exp_freq} == 0) {
		$patterns{$pattern_seq}->{ratio} = 0;
	    } else {
		$patterns{$pattern_seq}->{ratio} =  $patterns{$pattern_seq}->{observed_freq}/$patterns{$pattern_seq}->{exp_freq};
	    }
	    #### check threshold on occurrence probability ####
	    if ($patterns{$pattern_seq}->{ratio} < $ratio_threshold) {
		delete $patterns{$pattern_seq};
	    }
	}
    } elsif ($return{'occ'}) {
	foreach $pattern_seq (sort keys %patterns) {
	    if ($patterns{$pattern_seq}->{exp_occ} == 0) {
		$patterns{$pattern_seq}->{ratio} = 0;
	    } else {
		$patterns{$pattern_seq}->{ratio} =  $patterns{$pattern_seq}->{occ}/$patterns{$pattern_seq}->{exp_occ};
	    }
	    
	    #### check threshold on occurrence probability ####
	    if ($patterns{$pattern_seq}->{ratio} < $ratio_threshold) {
		delete $patterns{$pattern_seq};
	    }
	}
    }
    &CheckThresholds("ratio");
} ### CalcRatio



################################################################
## Concatenate return and threshold options from the CGI form
sub CGI_return_fields {
  my %field_group = (occ=>"occ",
		     freq=>"freq",
		     zscore=>"zscore",
		     rank=>"rank",
		     mseq=>"mseq",
		     ratio=>"ratio",
		     occ_sig=>"proba",
		     occ_P=>"proba",
		     occ_E=>"proba",
		     pos=>"pos"
		    );
  my %return_fields = ();
  foreach my $field (sort keys %field_group) {
    my $field_group = $field_group{$field};
    if ($query->param($field_group)) {
      $return_fields{$field_group} = 1;
    }

    ## Lower threshold value
    if (&IsReal($query->param('lth_'.$field))) {
      $parameters .= " -lth ".$field." ".$query->param('lth_'.$field);
    }

    ## Upper threshold value
    if (&IsReal($query->param('uth_'.$field))) {
      $parameters .= " -uth ".$field." ".$query->param('uth_'.$field);
    }
  }
  my $return_fields = join ",", sort(keys(%return_fields));

  unless ($return_fields) {
    &cgiError("You should select at least one option in the \"Return\" box.");
  } else {
    $parameters .= " -return ".$return_fields;
  }
}


################################################################
## Specify a selection of accepted patterns
sub ReadAcceptedPatterns {
  my ($accepted_pattern_file, $pattern_type) = @_;
  ($acc) = &OpenInputFile($accepted_pattern_file);

  &RSAT::message::TimeWarn("Reading accepted patterns from file", $accepted_pattern_file) if ($main::verbose >= 2);

  ## Read a file containing a selection of accepted patterns
  my $l = 0;
  while (<$acc>) {
    $l++;
    next if (/^;/);
    next if (/^--/);
    next if (/^#/);
    next unless (/\S/);
    chomp;
    my @fields = split /\s+/;
    my $accepted_pattern = lc($fields[0]);

    ## Check dyad syntax
    if ($pattern_type eq "dyads") {
      unless ($accepted_pattern =~ /[a-z]+n\{\d+}[a-z]/) {
	&RSAT::message::Warning($accepted_pattern, "Invalid pattern specitifcation in the accepted pattern files line", $l);
	next;
      }
    }
    $accepted_patterns{$accepted_pattern} = 1;

  }
  close $acc;

  ## Also accept reverse complementary patterns if patterns are counted on both strands
  if ($sum_rc) {
    foreach my $pattern (keys %accepted_patterns) {
      my $pattern_rc = lc(&SmartRC($pattern));
      $accepted_patterns{$pattern_rc} = 1;
    }
  }

  ## Report the number of accepted patterns
  if ($main::verbose >= 2) {
    &RSAT::message::TimeWarn(scalar(keys %accepted_patterns), "accepted patterns specified in file", $accepted_pattern_file);
    ## Report the list of accepted patterns
    &RSAT::message::Info("Accepted patterns", join(" ", "", sort keys %accepted_patterns))
      if ($main::verbose >= 5);
  }
}

return 1;
