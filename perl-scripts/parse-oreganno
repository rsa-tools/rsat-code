#!/usr/bin/perl



use strict;

use File::Basename;
use LWP;
use Getopt::Long;
use XML::LibXML;
use LWP::UserAgent;

## use strict;
BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}

require "RSA.lib";

=pod

=head1 NAME

parse-oreganno

=head1 DESCRIPTION

Parse ORegAnno (http://www.oreganno.org) database from a dump XML file. 
Only entries having non-deprecated ORegAnno StableID are returned.
The parser returns one output file for each of the four OReganno record type.
(TRANSCRIPTION FACTOR BINDING SITE, REGULATORY REGION, REGULATORY POLYMORPHISM, REGULATORY HAPLOTYPE).
The parser retrieves (optional) TFBS chromosomal positions from UCSC genome browser by using BLAT.
This parser makes use of the XML::LibXML, LWP and LWP::UserAgent libraries.

=head1 AUTHORS

=item Jean Valery Turatsinze <jturatsi@scmbb.ulb.ac.be>

=item Morgane Thomas-Chollier <morgane@scmbb.ulb.ac.be>

=head1 CATEGORY

=over

=item parsers

=back

=head1 USAGE

Download the ORegAnno XML dump file at http://www.oreganno.org/oregano/Dump.jsp
    
parse-oreganno -i inputfile [-v # -get_pos]

=head1 OPTIONS

=over

=item B<-help>: print this help message.

=item B<-v #>: verbosity level.

=item B<-i dump_xml_file>: Required option. The dump xml file from ORegAnno

=item B<-get_pos>: Optional. Get genomic positions from UCSC genome browser 
with BLAT (http://genome.ucsc.edu/cgi-bin/hgBlat). Requires internet connection.

=back

=head1 OUTPUT FILES

The parser returns 3 kinds of files: .tab, .gft and .log

=over

=item - B<.tab>: contains parsed data from the XML input file for each type of ORegAnno record

=item - B<.gft>: genome feature format as described in convert-features (convert-features -h). Contains the chromosomal
positions for the TFBS, calculated from a BLAT search at UCSC genome browser.

=item - B<.log>: WARNINGS during execution are logged in this file.

=back

=head1 OUTPUT FIELDS FOR .tab

=over

=item 1 -  ORegAnnoID

=item 2 -  recordType

=item 3 -  TFID

=item 4 -  TFname

=item 5 -  TFsource

=item 6 -  TFversion

=item 7 -  geneID

=item 8 -  geneName

=item 9 -  geneSource

=item 10 - geneVersion

=item 11 - lociName

=item 12 - speciesName

=item 13 - evidenceSubType

=item 14 - outcome

=item 15 - pubmedID

=head3 TRANSCRIPTION FACTOR BINDING SITE and REGULATORY REGION

=item 16 - sequence

=item 17 - seqWithFlank

=head3 REGULATORY POLYMORPHISM and REGULATORY HAPLOTYPE

=item 16 - referenceSequence

=item 17 - variantSequence


=back
 
=cut

my $help;
my $xmlInputFile;
my $get_pos;
my $verbose = 1;

###############################################
GetOptions(
	"help"          => \$help,
	"i=s"           => \$xmlInputFile,
	"v:s"		=> \$verbose,
	"get_pos"     	=> \$get_pos,
	);

printHelp() if $help;

###############################################
## ORegAnno XML dump is several xml files concatenated
## First need to extract each XML subfile
open XML, "<$xmlInputFile" or die "Cannot open XML file $xmlInputFile:$!"; 
my $xmlCount = 1;

## Here we get only the file name withou its full path
## this name will be used for the output files nomenclature
my $xmlfilename = basename $xmlInputFile;
while (my $line = <XML>){

	#look for <?xml
	 if ($line =~ /^<\?xml/) {
	 	my $partFileName = $xmlfilename."_part_".$xmlCount;
	 	open NEWXML, ">$partFileName" or die "Cannot write XML file $partFileName:$!";
	 	print NEWXML $line;	
	 # look for </oreganno>
	 } elsif ($line =~ /^<\/oreganno>/) {
	 	print NEWXML $line;	
	 	close NEWXML;
	 	$xmlCount++;
	 } else {
	 	print NEWXML $line;	
	 }
}
close XML;

###############################################
## Each partial XML file is parsed individually

## print header

## Four types of tab-delimited output files are returned : one file for each record type:
## TFBS
## Regulatory polymorphism
## Regulatory haplotype
## Regulatory region

my $oreg_version = $xmlfilename;
$oreg_version =~ s/cron.saved.//;
$oreg_version =~ s/.xml//;

my $TFBS_file = "ORegAnno_TFBS_annotations_".$oreg_version.".tab";
my $polymorphism_file = "ORegAnno_regulatory_polymorphism_annotations_".$oreg_version.".tab";
my $haplotype_file = "ORegAnno_regulatory_haplotype_annotations_".$oreg_version.".tab";
my $region_file = "ORegAnno_regulatory_region_annotations_".$oreg_version.".tab";
my $logFile = "ORegAnno_".$oreg_version.".log";

open LOG, ">$logFile"
	or die "Can't write to $logFile : $!";

## print headers
&printHeader($TFBS_file);
&printHeader($polymorphism_file);
&printHeader($haplotype_file);
&printHeader($region_file);

## parse XML files
print "Parsing XML file\n" if ($verbose >=2 );

for (my $i=1; $i < $xmlCount; $i++){
	my $parsedRecords = &XMLParse($xmlfilename."_part_".$i);
	
	## print records for current partial XML file
	&print2tab($parsedRecords);
	unlink($xmlfilename."_part_".$i);
}

###############################################
## Get genomic positions with BLAT from UCSC
## genome browser

if ($get_pos) {
	print "Exporting sequence with flank to fasta file\n" if ($verbose >=2 );
	
	## export the sequence with flank to a fasta file
	&to_fasta($TFBS_file);
		
	
	## IMPORTANT:This hash must be regularly updated!!!
	## convert species names from ORegAnno to UCSC
	## to get the list of species from the previously generate dfasta file :
	## grep "^>"  ORegAnno_TFBS_annotations_8-Mar-2007.fa | cut -f 2 -d '[' | sort | uniq
		
	my %species_name_conversion = (
				"Homo sapiens" 					=> "Human",
				"Rattus norvegicus" 			=> "Rat",
				"Mus musculus" 					=> "Mouse",
				"Gallus gallus" 				=> "Chicken",
				"Danio rerio" 					=> "Zebrafish",
				"Takifugu rubripes rubripes"	=> "Fugu",
				"Xenopus tropicalis"			=> "X. tropicalis",
				"Xenopus laevis"				=> "",
				"Oryctolagus cuniculus"			=> "", # rabbit
				"Caenorhabditis elegans"		=> "C. elegans",
				"Caenorhabditis briggsae"			=> "C. briggsae",
				"Human immunodeficiency virus 1"	=> "",
				"Ciona intestinalis"			=> "C .intestinalis",
				"Ciona savignyi"				=> "",
				"Drosophila melanogaster"		=> "D. melanogaster",
				"Saccharomyces cerevisiae"		=> "S. cerevisiae",	
	);
	
	## UCSC genome browser genome databases versions
	my $UCSC_genome_versions = &get_UCSC_databases(\%species_name_conversion);
	
	## get the seqWithFlank positions from UCSC
	my $fasta_file = $TFBS_file;
	$fasta_file =~ s/\.tab/\.fa/;
	my $UCSC_pos = &get_UCSC_positions($fasta_file,$UCSC_genome_versions,\%species_name_conversion);
	unlink($fasta_file);
	
	## print in feature format
	&print2feature($UCSC_pos,$UCSC_genome_versions);
	
}

close LOG;

###############################################
## SUBROUTINES
###############################################

sub printHelp{
	system "pod2text -c $0";
    exit()
}

sub XMLParse {
	my $partialXMLFile = shift;

	my %parsedRecords = ();
		
	## parse ORegAnno XML dump file
	my $parser = XML::LibXML->new();
	my $tree = $parser->parse_file($partialXMLFile);
	$tree->indexElements();
	my $root = $tree->getDocumentElement;
	my @records = $root->getElementsByTagName('record');

	foreach my $i (0..$#records) {
		my @thisParsedRecord =();

			# check wether the record id deprecated
			my $deprecatedID  = $records[$i]->findvalue('deprecatedByStableId');
			# if there is no deprecatedID => record is to be processed
			if ($deprecatedID eq "") {
					## get fields of interest
					my $stableID = $records[$i]->findvalue('stableId');
					my $type  = $records[$i]->findvalue('type');
					my $TFID = $records[$i]->findvalue('tfId');
					my $TFName = $records[$i]->findvalue('tfName');
					my $TFSource = $records[$i]->findvalue('tfSource');
					my $TFVersion = $records[$i]->findvalue('tfVersion');
					my $geneID = $records[$i]->findvalue('geneId');
					my $geneName = $records[$i]->findvalue('geneName');			
					my $geneSource = $records[$i]->findvalue('geneSource');
					my $geneVersion = $records[$i]->findvalue('geneVersion');
					my $lociName = $records[$i]->findvalue('lociName');
					my $speciesName  = $records[$i]->findvalue('speciesName');
								
					# evidence
					my @evidenceSet = $records[$i]->getElementsByTagName('evidenceSet');
					my $evidences;				
					my $count = 1;					
					while ($evidenceSet[0]->getElementsByTagName('evidenceSubtypeStableId')->get_node($count))  {
						my $node = $evidenceSet[0]->getElementsByTagName('evidenceSubtypeStableId')->get_node($count);
						$evidences .= $node->textContent().",";
						$count++
					}
					chop($evidences);					
									
					my $outcome = $records[$i]->findvalue('outcome');
					my $pubmedID = $records[$i]->findvalue('reference');
					
					# sequences
					if (($type eq "TRANSCRIPTION FACTOR BINDING SITE")||($type eq "REGULATORY REGION")) {
						my $sequence = $records[$i]->findvalue('sequence');
						my $seqWithFlank  = $records[$i]->findvalue('sequenceWithFlank');	
						
						@thisParsedRecord = (trim_string($stableID), trim_string($type), trim_string($TFID), trim_string($TFName), trim_string($TFSource), trim_string($TFVersion),
									trim_string($geneID), trim_string($geneName), trim_string($geneSource), trim_string($geneVersion),trim_string($lociName), trim_string($speciesName), 
									trim_string($evidences), trim_string($outcome), trim_string($pubmedID),   trim_string($sequence), trim_string($seqWithFlank));
						$parsedRecords{$stableID} = \@thisParsedRecord;
						
					} elsif (($type eq "REGULATORY POLYMORPHISM")||($type eq "REGULATORY HAPLOTYPE")) {	
						
						# variant sequences
						my @variationSet = $records[$i]->getElementsByTagName('variationSet');
						my $refsequences;
						my $varsequences;
						
						my $count = 1;					
						while ($variationSet[0]->getElementsByTagName('referenceSequence')->get_node($count))  {
							my $node = $variationSet[0]->getElementsByTagName('referenceSequence')->get_node($count);
							$refsequences .= $node->textContent().",";
							$count++
						}						
						$count = 1;					
						while ($variationSet[0]->getElementsByTagName('variantSequence')->get_node($count))  {
							my $node = $variationSet[0]->getElementsByTagName('variantSequence')->get_node($count);
							$varsequences .= $node->textContent().",";
							$count++
						}
						chop($refsequences);
						chop($varsequences);
						
						# trim_string whitespaces: strip blank space from the beginning/end of each string		
						@thisParsedRecord = (trim_string($stableID), trim_string($type), trim_string($TFID), trim_string($TFName), trim_string($TFSource), trim_string($TFVersion),
									trim_string($geneID), trim_string($geneName), trim_string($geneSource), trim_string($geneVersion),trim_string($lociName), trim_string($speciesName), 
									trim_string($evidences), trim_string($outcome), trim_string($pubmedID),  trim_string($refsequences), trim_string($varsequences));
						}	
						$parsedRecords{$stableID} = \@thisParsedRecord;
					}			
			}
	
	return (\%parsedRecords);
}

sub printHeader{
	
	my $outFile = shift;
	open OUT, ">$outFile" or die "Cannot write to output file $outFile:$!"; 
	
	if (($outFile eq $TFBS_file)||($outFile eq $region_file)){
		# header line
		my $header = "#ORegAnnoID\trecordType\tTFID\tTFname\tTFsource\tTFversion\t".
				"geneID\tgeneName\tgeneSource\tgeneVersion\tlociName\tspeciesName\tevidenceSubType\toutcome\tpubmedID\t".
				"sequence\tseqWithFlank\n";
		#print
		if ($outFile){
			print OUT "; Column names:\n".
				   ";\n".
				   ";1 -  ORegAnnoID\n".
				   ";2 -  recordType\n".
				   ";3 -  TFID\n".
				   ";4 -  TFname\n".
				   ";5 -  TFsource\n".
				   ";6 -  TFversion\n".
				   ";7 -  geneID\n".
				   ";8 -  geneName\n".
				   ";9 -  geneSource\n".
				   ";10 - geneVersion\n".
				   ";11 - lociName\n".
				   ";12 - speciesName\n".
				   ";13 - evidenceSubType\n".
				   ";14 - outcome\n".
				   ";15 - pubmedID\n".
				   ";16 - sequence\n".
				   ";17 - seqWithFlank\n";
			print OUT $header;
		}		
	}
	
	elsif (($outFile eq $polymorphism_file)||($outFile eq $haplotype_file)){
		# header line
		my $header = "#ORegAnnoID\trecordType\tTFID\tTFname\tTFsource\tTFversion\t".
				"geneID\tgeneName\tgeneSource\tgeneVersion\tlociName\tspeciesName\tevidenceSubType\toutcome\tpubmedID\t".
				"referenceSequence\tvariantSequence\n";
		#print
		if ($outFile){
			print OUT "; Column names:\n".
				   ";\n".
				   ";1 -  ORegAnnoID\n".
				   ";2 -  recordType\n".
				   ";3 -  TFID\n".
				   ";4 -  TFname\n".
				   ";5 -  TFsource\n".
				   ";6 -  TFversion\n".
				   ";7 -  geneID\n".
				   ";8 -  geneName\n".
				   ";9 -  geneSource\n".
				   ";10 - geneVersion\n".
				   ";11 - lociName\n".
				   ";12 - speciesName\n".
				   ";13 - evidenceSubType\n".
				   ";14 - outcome\n".
				   ";15 - pubmedID\n".
				   ";16 - referenceSequence\n".
				   ";17 - variantSequence\n";
			print OUT $header;
		}		
	}
	
	close OUT;
}


sub print2tab{
	my $parsedRecords_ref = shift;
	my %parsedRecords = %$parsedRecords_ref;
	
	# record lines
	foreach my $recordToPrint (keys(%parsedRecords)){
		my $type = $parsedRecords{$recordToPrint}->[1];
	
		# get records with type TRANSCRIPTION FACTOR BINDING SITE
		if ($type eq "TRANSCRIPTION FACTOR BINDING SITE"){
			open OUT, ">>$TFBS_file" or die "Cannot write to output file $TFBS_file:$!"; 
			foreach my $field (@{$parsedRecords{$recordToPrint}}){
				print OUT $field."\t";
			}
			print OUT "\n";
			close (OUT);
		}
		# get records with type Regulatory region
		if ($type eq "REGULATORY REGION"){
			open OUT, ">>$region_file" or die "Cannot write to output file $region_file:$!"; 
			foreach my $field (@{$parsedRecords{$recordToPrint}}){
				print OUT $field."\t";
			}
			print OUT "\n";
			close (OUT);
		}
		# get records with type Regulatory polymorphism
		if ($type eq "REGULATORY POLYMORPHISM"){
			open OUT, ">>$polymorphism_file" or die "Cannot write to output file $polymorphism_file:$!"; 
			foreach my $field (@{$parsedRecords{$recordToPrint}}){
				print OUT $field."\t";
			}
			print OUT "\n";
			close (OUT);
		}

	
		# get records with type Regulatory haplotype
		if ($type eq "REGULATORY HAPLOTYPE"){
			open OUT, ">>$haplotype_file" or die "Cannot write to output file $haplotype_file:$!"; 
			foreach my $field (@{$parsedRecords{$recordToPrint}}){
				print OUT $field."\t";
			}
			print OUT "\n";
			close (OUT);
		}
		
	}
}

## print result in feature format
sub print2feature{
	my $UCSC_pos = shift;
	my $UCSC_genome_versions = shift;

	my $out_pos_file = $TFBS_file;
	$out_pos_file =~ s/.tab$/.gft/;
	
	## feat header
	open OUT, ">$out_pos_file" or die "Cannot write to output file $out_pos_file:$!";
	
	print OUT "; Column names:\n".
				   ";\n".
				   ";1 -  ORegAnnoID\n".
				   ";2 -  recordType\n".
				   ";3 -  name\n".				   
				   ";4 -  chrom_name\n".
				   ";5 -  start\n".				   
				   ";6 -  end\n".
				   ";7 -  strand\n".
				   ";8 -  description\n".
				   ";9 -  genomeDBversion\n".
				   ";10-  organism\n".
				   ";11-  TFname\n";

				  
	print OUT "#ORegAnnoID\trecordType\tname\tchrom_name\tstart\tend\tstrand\tdescription\tgenomeDBversion\torganism\tTFname\n";
	
	
	## calculate positions of the actual site, without flanks	
	## get ORegAnno IDs, sequence and seqWithFlank and TF names from the XML parsed file
	my $oregId =`grep -v '^;' $TFBS_file | grep -v '^#' | cut -f 1`;
	my $oregSeq =`grep -v '^;' $TFBS_file | grep -v '^#' | cut -f 16`;
	my $oregSeqWithFlank =`grep -v '^;' $TFBS_file | grep -v '^#' | cut -f 17`;
	my $TFname = `grep -v '^;' $TFBS_file | grep -v '^#' | cut -f 4`;
	
	my @oregIds = split (/\n/,$oregId);
	my @oregSeqs = split (/\n/,$oregSeq);
	my @oregSeqWithFlanks = split (/\n/,$oregSeqWithFlank);
	my @TFnames = split (/\n/,$TFname);
	
	# create an index to ease and accelerate access to sequences
	my %invertedIDhash = ();
	foreach my $i (0..$#oregIds) {
		$invertedIDhash{$oregIds[$i]} = $i;
	}
		
	## get the positions of sequence of the site, without flanks	 
	foreach my $positionsToPrint (keys(%$UCSC_pos)){
		## UCSC seqWithFlank positions	
		my @position_data = split(/\t/,$UCSC_pos->{$positionsToPrint});
		
		my $queryID = $position_data[0];
		my $index_of_ID = $invertedIDhash{$queryID};
		my $querySize = $position_data[1];
		my $strand =$position_data[2];
		if ($strand =~ /\+/) {
			$strand = "D";
		}else {
			$strand = "R";
		}
		my $chromName =$position_data[3];
		my $flankstart = $position_data[4];
		my $flankend =$position_data[5];
		my $species = $position_data[6];
		my $db_version = $UCSC_genome_versions->{$species};
		my $TF = $TFnames[$index_of_ID];
		
		## get sequence position relative to flanking sequences	
		my $seq = $oregSeqs[$index_of_ID];
		my $seqWithFlank  = $oregSeqWithFlanks[$index_of_ID];
		my $positionInFlank = index($seqWithFlank, $seq);
		my $TFBS_found = substr($seqWithFlank,$positionInFlank,length($seq));
		## check that the TFBS sequence is at this position (usually displayed as capital letters)
		unless ($TFBS_found =~ /^[A-Z]+$/) {
			print LOG "WARNING: ".$queryID. ": TFBS sequence found in flanking sequence is not in upper case\n"; 
		}
				
		
		my $seq_start;
		my $seq_end;
		
		## calculate chromosomal positions
		$seq_start = $flankstart + $positionInFlank;
		$seq_end = $seq_start + length($seq)-1;
		
		## print results
		print OUT $queryID."\tTFBS\t".$queryID."\t".$chromName."\t"
		.$seq_start."\t".$seq_end."\t".$strand."\t".$seq."\t".$db_version."\t".$species."\t".$TF."\n";	
	}
	close OUT;
}

# Perl trim_string function to remove whitespace from the start and end of the string
sub trim_string()
{
	my $string = shift;
	$string =~ s/^\s+//;
	$string =~ s/\s+$//;
	return $string;
}

# retrive fasta sequences from the parsed oreganno file
sub to_fasta{
	my $parsed_file = shift @_;
	my $fasta_file = $parsed_file;
	$fasta_file =~ s/\.tab/\.fa/;
	 `grep -v '^;' $parsed_file | grep -v '^#' | cut -f 1,17,12 | awk 'BEGIN { FS = "\\t" } ;{print ">"\$1" ["\$2"]\\n"\$3}' > $fasta_file`;
}

# get chromosomal positions from UCSC genome browser
# using BLAT (http://genome.ucsc.edu/cgi-bin/hgBlat)
sub get_UCSC_positions {
	
	my $fasta_file = shift @_;
	my $UCSC_genome_versions = shift @_;
	my $species_name_conversion = shift @_;
	
	my %UCSC_pos = ();
	
	## get Fasta sequences
	open FASTA, "< $fasta_file"
		or die "Can't read from $fasta_file : $!";
	my @fasta_content = <FASTA>;
	close FASTA;
	
	## prepare the query by organism
	my %queryByOrganism = ();
	foreach my $species (keys(%$UCSC_genome_versions)) {
		$queryByOrganism{$species} = "";	
	}
	
	print "Preparing queries for BLAT at UCSC\n" if ($verbose >=2 );
	while (@fasta_content) {
		my $header = shift @fasta_content;
		my $seq = shift @fasta_content;
		
		## get ORegAnno species name
		my $oregSpecies = $header;
		$oregSpecies =~ s/^.*\[//;
		$oregSpecies =~ s/].*$//;	
		$oregSpecies = &trim_string($oregSpecies);
		
		## get corresponding UCSC species name
		my $UCSC_species = $species_name_conversion->{$oregSpecies};
		next if ($UCSC_species eq "") ;

		## concatenate queries for each organism
		$queryByOrganism{$UCSC_species} .= $header.$seq;	
	}	

	## Sending jobs to UCSC server : every 15 seconds, by pack of 
	## maximum 25 sequences, no more than 5000 hits a day
	## we will send 24 sequences at a time on the server
	## each organism is treated independently
	print "Sending BLAT jobs to UCSC\n" if ($verbose >=2 );
	my $pack = 24;
	foreach my $species (keys(%queryByOrganism)) {
		print "\t for organism $species\n" if ($verbose >=2 );
			my $count = 0;
			my $query;
			my @queriesToSend = split (/\n/, $queryByOrganism{$species});
			
			while (@queriesToSend) {
				my $header = shift @queriesToSend;
				my $seq = shift @queriesToSend;
				 
				$query  .= $header."\n".$seq."\n";
				$count++;
				
				## send jobs to UCSC
				if (&RSAT::util::IsNatural($count/$pack)||(!@queriesToSend)){
					print "\t\t$count analyzed sequences for $species\n" if ($verbose >=2 );
	
					my $ua = LWP::UserAgent->new;	
					my $url = 'http://genome.ucsc.edu/cgi-bin/hgBlat';
					
					sleep 15; #waiting time to prevent being banished from UCSC server
					my $response = $ua->post( $url,
 	 			  [ 
 	 	   		 	'org' => $species, 
 	 	   		 	'db' => $UCSC_genome_versions->{$species}, 
  		    		'type' => 'DNA',
  	 	   			'sort' => 'query,score',
  	 	   			'output' => 'hyperlink',
  	 	   			'userSeq' => $query
  		 		 ]
 				 );
 
  			die "$url error: ", $response->status_line unless $response->is_success;
  			die "Weird content type at $url -- ", $response->content_type unless $response->content_type eq 'text/html';


 			## get the result table
 			my @splitted_response = split (/TT>/,$response->content );
 			my $table_result = $splitted_response[1];
 			
 			## parse the result table
 			my @table_to_parse = split (/\n/,$table_result);
 			my %result_fields = ();

 			## each cell of the array contains 1 line of results
 			foreach my $i (0..$#table_to_parse) { 
 				next unless ($table_to_parse[$i] =~/^<A\s+HREF/);
 				chomp($table_to_parse[$i]);
 				my $hitLine = $table_to_parse[$i];
 				$hitLine =~ s/^<.*details<\/A>\s*//;
 				my @lineContent = split (/\s+/,$hitLine);
 				
				## get query name
				my $queryName = $lineContent[0];
		
				## get query size
				my $querySize = $lineContent[4];
				
				## get hit length (span field)
				my $hitLength = $lineContent[10];
				$hitLength =~ s/,.*//g;
				
				## get strand
				my $strand = $lineContent[7];
				
				## get chromosome name
				my $chromName = "chr".$lineContent[6];
				
				## get chromosomal start position
				my $start = $lineContent[8];
				
				## get chromosomal end position
				my $end = $lineContent[9];

				## save current hit
				if ($querySize == $hitLength) {
					$UCSC_pos{$queryName} = $queryName."\t".
					$querySize."\t".$strand."\t".$chromName."\t".$start."\t".$end."\t".$species;
				}
				## discard current hit if already assigned
				elsif ($UCSC_pos{$queryName}){next;}
				## if several hits, and none is of the same size as the query
				elsif ($table_to_parse[$i+1] !~ /$queryName/) { ## next line is a different TFBS
					print  LOG "WARNING: ".$queryName." exact match was not found on the UCSC genome\n";
				}				
			}			
			$query ="";
			}
		}
	}
	return (\%UCSC_pos);
}

## get the latest database version for each genome of interest
## by calling the BLAT server and parsing the HTML query page
sub get_UCSC_databases{
	my $species_name_conversion = shift @_;
	my %UCSC_genome_versions = ();
	
	my $ua = LWP::UserAgent->new;	
	my $url = 'http://genome.ucsc.edu/cgi-bin/hgBlat';
			
	print "Getting latest genome assemblies name from UCSC\n" if ($verbose >=2 );
	my @UCSC_species = values %$species_name_conversion;	 
  	for my $species (@UCSC_species) {	
  		next if ($species eq "") ;
		
		## get the query page that contains the available versions of genome assemblies for the desired organism
		my $response = $ua->post( $url,
  				  [ 
  	   			 'org' => $species, 
   		 		]
 		 		);
 
  		die "$url error: ", $response->status_line unless $response->is_success;
  		die "Weird content type at $url -- ", $response->content_type unless $response->content_type eq 'text/html';
		
		## get the db
		if ( $response->content =~ /<SELECT NAME=\"db\">\s*<OPTION SELECTED VALUE=\"(\w+)\">/){
			$UCSC_genome_versions{$species} = $1;
		}
			
  	}
  	
  	return (\%UCSC_genome_versions);
} 





