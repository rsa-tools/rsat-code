#!/usr/bin/perl
use CGI;
#require "cgi-lib.pl";

### CVS: moived ENV{SERVER_ADMIN} to the config file

$main::verbose = 0;
require "RSA.seq.lib";
require "RSA.stat.lib";
require RSAT::organism;
require RSAT::contig;
require RSAT::error;
require RSAT::util;

umask 0022;

## CVS: created separate objects for handling different methods
## RSAT::organism (check_name, is_supported)
## RSAT::error (FatalError, cgiError)
## RSAT::util (IsNatureal, IsReal, IsInteger, trim, round)
## ReadFeatures became RSAT::organism::LoadFeatures

############################################################################
############################################################################
############################################################################
############################################################################
############################################################################
####                                                                    ####
####                            RSA.lib                                 ####
####                                                                    ####
#### Regulatory Sequence Analysis Tools (RSA-tools)
####  Project started in 1997 by Jacques van Helden (jvanheld@scmbb.ulb.ac.be)
####  a Perl library with diverse procedures
####  used by rsa-tools perl scripts


############################################################################
########################## PATH DEFINITION ##############################
############################################################################


#### read config files #####
if ($0 =~ /([^(\/)]+)$/) {
    $config_file = "$`../RSA.config";
    require $config_file;
    if ($ENV{'RSA_LOCAL_CONFIG'}) {
	if (-e $ENV{'RSA_LOCAL_CONFIG'}) {
	    if (-r $ENV{'RSA_LOCAL_CONFIG'}) {
		require $ENV{'RSA_LOCAL_CONFIG'};
	    } else {
		warn (";WARNING: cannot read local config file ", 
		      $ENV{'RSA_LOCAL_CONFIG'}, 
		      "\n"), 
	    }
	} else {
	    warn (";WARNING: local config file ", 
		  $ENV{'RSA_LOCAL_CONFIG'}, 
		  " does not exist\n"), 
	}
    }
} else {
    &RSAT::error::FatalError("Error: problem when opening config file. Please contact jvanheld\@scmbb.ulb.ac.be");
}

$BIN = "$RSA/bin";
$LIB = "$RSA/lib";
$TMP = "$RSA/public_html/tmp";
$LOGS = "$RSA/logs";
$SCRIPTS = "$RSA/perl-scripts";

my $login = getlogin();

################################################################
## Redirect queries to a remote server
## 
if ($REMOTE_SERVER) {
    if (($login eq "webserv") || !($login)) {
	$NICE = "nice +5";
	$RSH = "rsh -l jvanheld ${REMOTE_SERVER} $NICE";
	$SCRIPTS = "$RSH /home/rsa/rsa-tools/perl-scripts";
	$BIN = "$RSH /home/rsa/rsa-tools/bin";
    }
}


$HTML = "$RSA/public_html"; 
$WWW_TMP = "$WWW_RSA/tmp";
#$ENV{SERVER_ADMIN} = "jvanheld\@scmbb.ulb.ac.be";

$counter_file = "$LOGS/count-file";
($sec, $min, $hour,$day,$month,$year) = localtime(time);
$log_file = sprintf "$LOGS/log-file_${config_site}_%04d_%02d", $year+1900,$month+1;

$script_name = &RSAT::util::ShortFileName($0);

$date = &AlphaDate();

############################################################################
############################ GLOBAL VARIABLES ##############################
############################################################################


############################################################################
##################### PERL SUBROUTINE DEFINITION ###########################
############################################################################



################################################################
## echo a command and send it to the system
## Usage:
##   &doit($command, $dry, $die_on_error, $verbose, $batch, $job_prefix);
sub doit {
    my ($command, $dry, $die_on_error, $verbose,$batch, $job_prefix) = @_;
    my $wd = `pwd`;
    chomp $wd;

    if ($batch) {
	## Store the command in a sh script (the job)
	my $job_dir = "jobs";
	my $job_prefix = $job_prefix || "doit";
	&RSAT::util::CheckOutDir($job_dir);
	my $job = `mktemp ${job_dir}/${job_prefix}.XXXXXX`;
	chomp $job;
	open JOB, ">$job";
	print JOB "( cd ".$wd." ; ";
	print JOB $command;
	print JOB " )", "\n";
	close JOB;
	&RSAT::message::TimeWarn(join("\t", "Job queued", $wd."/".$job)) if ($main::verbose >= 0);

	## Send the command to a batch queue on a PC cluster
	## The default values are for internal use in the SCMBB, but
	## alternative values can be specified by environment variables
	my $cluster_queue = $ENV{CLUSTER_QUEUE} || "rsa";
	my $cluster_master=$ENV{CLUSTER_MASTER} || "merlin.scmbb.ulb.ac.be";
	my $batch_mail=$ENV{BATCH_MAIL} || "a";
	&doit("qsub -m ".$batch_mail." -q ".$cluster_queue."\@".$cluster_master." -N ${job} -j oe -o ${job}.log ${job}", $dry, $die_on_error,$verbose,0);

    } else {
	## Verbose
	if ($main::verbose >= 1) {
	    &RSAT::message::TimeWarn("Working dir", $wd);
	    &RSAT::message::TimeWarn($command);
	}

	## Run the command immediately
	unless ($dry) {
	    my $error = system $command;
	    if ($die_on_error) {
		if ($error == -1) {
		    &RSAT::error::FatalError("Could not execute the command\n\t$command");
		} elsif ($error) {
		    &RSAT::error::FatalError("Error $error occurred during execution of the command\n\t$command");
		}
	    } else {
		return ($error);
	    }
	}
    }
}



################################################################
## Name of the expected frequency file, 
## given the organism, oligo length and background model
##
sub ExpectedFreqFile {
    my ($organism_name, $oligo_length, $background, %args) = @_;
    my $exp_freq_file = "";
    my $str = $args{str} || "-2str";
    my $noov = $args{noov} || "-noov";
    
    #### organism
    &CheckOrganism($organism_name);
    
    #### check oligo length
    unless ($oligo_length) {
	&FatalError("You must specify the oligonucleotide length for the background model (expected frequency file)");
    }

    unless (&IsNatural($oligo_length)) {
	&RSAT::error::FatalError("Invalid oligonucleotide length : must be a natural number");
    }    
    if ($oligo_length < 1) {
	&RSAT::error::FatalError("Invalid oligonucleotide length : must be >= 1");
    }
    if ($oligo_length > 8) {
	&RSAT::error::FatalError("Invalid oligonucleotide length : must be <= 8");
    }

    my $data_dir = $supported_organism{$organism_name}->{'data'};
    $exp_freq_file = $data_dir."/oligo-frequencies/";
    if ($background eq "upstreamL") {
	$exp_freq_file .= "_".$organism_name;
	$exp_freq_file .= "_allup500";
	$exp_freq_file .= $oligo_length."nt";
	$exp_freq_file .= $str;
	$exp_freq_file .= $noov;
	$exp_freq_file .= "_freq.tab";

    } else {
	$exp_freq_file .= $oligo_length."nt";
	$exp_freq_file .= "_".$background;
	$exp_freq_file .= "_".$organism_name;
	#### build the name of the expected frequency file 
	if ($noov eq "-noov") {
	    $noov_suffix = "-noov";
	} else { 
	    $noov_suffix = "-ovlp";
	}
	$exp_freq_file .= $noov_suffix;
	$exp_freq_file .= $str;
	$exp_freq_file .= ".freq";
    }

    ## Check the existence of the exp freq file
    unless ((-e $exp_freq_file) || 
	    (-e $exp_freq_file.".gz")) {
	&RSAT::error::FatalError("Cannot find expected frequency file $exp_freq_file");
    }

    warn "; Expected frequency file\t", $exp_freq_file, "\n" if ($main::verbose >= 2);
    return $exp_freq_file;
}


################################################################
# Read expected occurrences and variance from a calibration file
sub ReadCalibration {
    my ($calibration_file, $sum_rc) = @_;
    
    my ($cal) = &OpenInputFile($calibration_file);
    my $l=0;
    while (<$cal>) {
	$l++;
	chomp();
	next if (/^;/);
	next unless (/\S/);
	my @fields =  split /\s+/;
	my $pattern_seq = lc(shift(@fields));
	my $pattern_id = $pattern_seq;

	## Check if the 1st field contains a pair of reverse complements
	if ($pattern_seq =~ /(\S+)\|/) {
	    $pattern_seq = $1;
	}
	
	## Check if the second field contains the ID
	if ($fields[0] =~ /(\S+)\|/) {
	    $pattern_id = shift(@fields);
	}

	## Expected occurrences
	my $exp_occ = $fields[0];
	&RSAT::error::FatalError("Invalid expected occurrences\t${exp_occ}") unless ((&IsReal($exp_occ)) && ($exp_occ >= 0));
	$patterns{$pattern_seq}->{exp_occ} = $exp_occ;

	## Expected variance
	my $exp_var = $fields[2];
	&RSAT::error::FatalError("Invalid expected variance") unless ((&IsReal($exp_var)) && ($exp_ocvar >= 0));
	$patterns{$pattern_seq}->{exp_var} = $exp_var;

	warn join("\t", "; calibration", $pattern_seq, 
		  $patterns{$pattern_seq}->{exp_occ},
		  $patterns{$pattern_seq}->{exp_var}), "\n" if ($main::verbose >= 5);

    }
    close $cal if ($calibration_file);
    
    #### check if reverse complements were included in the expected freq file;
    #### if not, infer them from the direct strand 
    foreach my $pattern_seq (sort keys %patterns) {
  	my $rc = lc(&SmartRC($pattern_seq));
  	if (($patterns{$rc}->{exp_occ} <= 0) &&
  	    ($patterns{$pattern_seq}->{exp_occ})) {
  	    $patterns{$rc}->{exp_occ} = $patterns{$pattern_seq}->{exp_occ};
  	    $patterns{$rc}->{exp_var} = $patterns{$pattern_seq}->{exp_var};
	    #print STDERR join "\t", $pattern_seq,  $patterns{$pattern_seq}->{exp_freq}, $rc, $patterns{$rc}->{exp_freq}, "\n";
  	}
    }
}


################################################################
# Read pattern expected frequencies from a file
#
sub ReadExpectedFrequencies {
    my ($exp_freq_file, $sum_rc, $rescale_freq) = @_;
    &RSAT::message::TimeWarn ("Reading expected frequency file", $exp_freq_file) if ($main::verbose >= 2);
    my ($exp) = &OpenInputFile($exp_freq_file);
    my $l=0;
    while (<$exp>) {
	$l++;
	chomp();
	next if (/^;/);
	next unless (/\S/);

	my @fields =  split /\s+/;
	$pattern_seq = lc($fields[0]);
	next unless $pattern_seq;

	warn join "\t", "fields", join ("\t", @fields), "\n" if ($main::verbose >= 10);

	#### check the format and extract expected frequency
	if (&IsReal($fields[1])) {
	    ### second field contains the expected frequency (old format)
	    $patterns{$pattern_seq}->{exp_freq} = $fields[1];
	    $file_type="undef";

  	} elsif (($fields[1] =~ /(\S+)\|(\S+)/) && (&IsReal($fields[2]))) {
	    #### second field contains the ID as a pair of reverse complements
	    $file_type = "2str";
  	    $fw = lc($1);
  	    $rc = lc($2);
  	    $patterns{$rc}->{exp_freq} = $fields[2];
  	    $patterns{$fw}->{exp_freq} = $fields[2];

  	} elsif	(($fields[1] eq $fields[0]) &&(&IsReal($fields[2]))) {
	    #### second field contains the ID which is identical to the pattern (single strand pattern)
	    $file_type = "1str";
  	    $patterns{$fields[0]}->{exp_freq} = $fields[2];

	} else {
	    ### unrecognized format
	    &RSAT::error::FatalError("Invalid expected frequency in file $exp_freq_file at line $l\n");
	}
	
	if ($patterns{$pattern_seq}->{exp_freq} < 0) {
	    &RSAT::error::FatalError("Expected frequency cannot be negative\t$pattern_seq\t".$patterns{$pattern_seq}->{exp_freq});
	}
    }
    close $exp if ($exp_freq_file);
    

    #### check if reverse complements were included in the expected freq file;
    #### if not, infer them from the direct strand 
    foreach my $pattern_seq (sort keys %patterns) {
  	my $rc = lc(&SmartRC($pattern_seq));
  	if ((!defined($patterns{$rc}->{exp_freq})) &&
  	    ($patterns{$pattern_seq}->{exp_freq})) {
  	    $patterns{$rc}->{exp_freq} = $patterns{$pattern_seq}->{exp_freq};
#	    warn join "\t", $pattern_seq,  $patterns{$pattern_seq}->{exp_freq}, $rc, $patterns{$rc}->{exp_freq}, "\n" if ($main::verbose >= 10);
  	}
    }


    #### sum expected frequencies by reverse complements
    if (($sum_rc) && ($file_type eq "1str")) {
	&SumExpectedFrequencies(%patterns);
    }

    #### make sure that the sum of frequencies is positive
    my $freq_sum = 0;
    foreach my $pattern_seq (keys %patterns) {
	$freq_sum += $patterns{$pattern_seq}->{exp_freq};
    }
    if ($freq_sum <= 0) {
	&RSAT::error::FatalError("Error with the expected frequency file : the sum must be strictly positive\t$freq_sum");
    }
    
    #### rescale expected frequencies to have a sum of 1
    if ($rescale_freq) {
	warn "; Rescaling expected frequencies\n" if ($main::verbose >=1);
	foreach my $pattern_seq (keys %patterns) {
	    $patterns{$pattern_seq}->{exp_freq} /= $freq_sum;
	}
    }
    
}


################################################################
## Sum expected frequencies
##
sub SumExpectedFrequencies {
    my (%patterns) = @_;
    my %freq_2str = ();
    foreach my $pattern_seq (sort keys %patterns) {
	my $rc = lc(&SmartRC($pattern_seq));
	if ($rc eq $pattern_seq) {
	    #### palindromic sequence
	    $freq_2str{$pattern_seq} =   $patterns{$pattern_seq}->{exp_freq};
	} else {
	    #### non-palindromic sequence : the expected frequency is the sum of the sequence + its reverse complement 
	    $freq_2str{$pattern_seq} =  $freq_2str{$rc} = $patterns{$rc}->{exp_freq} + $patterns{$pattern_seq}->{exp_freq};
	}
	warn join ("\t", 
		   $pattern_seq,  
		   $patterns{$pattern_seq}->{exp_freq}, 
		   $freq_2str{$pattern_seq},
		   $rc, 
		   $patterns{$rc}->{exp_freq}, 
		   $freq_2str{$rc},
		   ), "\n" if ($main::verbose >= 5);
    }

    foreach my $pattern_seq (sort keys %patterns) {
	my $rc = &SmartRC($pattern_seq);
	$patterns{$pattern_seq}->{exp_freq} = $freq_2str{$pattern_seq};
	$patterns{$rc}->{exp_freq} = $freq_2str{$pattern_seq};
    }

}


################################################################
# Calculate conditional residue probabilities on the basis of specified
# oligonucleotide frequencies
sub CalcConditionalProbabilities {
    my ($exp_freq_file) = @_;

    &ReadExpectedFrequencies($exp_freq_file) ;

    warn "; Calculating conditional probabilities\n" if ($main::verbose >= 2);
    
    foreach my $pattern_seq (keys %patterns) {
	$expected_freq{$pattern_seq} = $patterns{$pattern_seq}->{exp_freq};
    }

    #### calculate alphabet from expected frequency keys
    foreach my $pattern_seq (keys %patterns) {
	my @residues = split "|", $pattern_seq;
	foreach my $r (@residues) {
	    $letter{$r} = 1;
	}
    }
    @letters = keys (%letter);

    #### calculate subword frequencies
    %subword_freq = ();
    foreach my $oligo_seq (keys %expected_freq) {
	my $subword = substr($oligo_seq,0,-1);
	$subword_freq{$subword} += $expected_freq{$oligo_seq};
    }

    foreach $subword (keys %subword_freq) {
	for $l (0..$#letters) {
	    $word = lc($subword.$letters[$l]);
	    if ($subword_freq{$subword} > 0) {
		$conditional_proba{$subword}[$l] =  $expected_freq{$word}/$subword_freq{$subword};
	    } else {
		$conditional_proba{$subword}[$l] =  "NA";
	    }
	}
    }

    #### calculate cumulative conditional residue probabilities
    foreach $subword (keys %subword_freq) {
	$word = lc($subword.$letters[0]);
	$cum_letter_freq{$subword}[0] = $expected_freq{$word};
	$cum_letter_freq{$subword}[0]/=$subword_freq{$subword} if $expected_freq{$word};
# 	warn (join ("\t", 
# 		    $subword, 
# 		    $subword_freq{$subword},
# 		    $word, 
# 		    $expected_freq{$word},
# 		    $cum_letter_freq{$subword}[0]
# 		    ), "\n");
	for $l (1..$#letters) {
	    $word = lc($subword.$letters[$l]);
	    $cum_letter_freq{$subword}[$l] = $cum_letter_freq{$subword}[$l-1];
	    $cum_letter_freq{$subword}[$l] += $expected_freq{$word}/$subword_freq{$subword} if $expected_freq{$word};
#	    warn (join ("\t", 
#			$subword, 
#			$subword_freq{$subword},
#			$word, 
#			$expected_freq{$word},
#			$cum_letter_freq{$subword}[$l]
#			), "\n");
	}
    }
    @subword_keys = sort keys %subword_freq;
}

################################################################
#### increment the counter file for monitoring web access
sub UpdateCounterFile {
    my $nb_visitors = 1;

    ### read previous counter value
    if (-e $counter_file) {
	open(COUNTER, "<$counter_file");
	#flock(COUNTER, 2);
	$nb_visitors = <COUNTER>;
	#flock(COUNTER,8);
	close(COUNTER);
	$nb_visitors++;
    }
    
    ### save new counter value
    open(COUNTER, ">$counter_file");
    #flock(COUNTER,2);
    print COUNTER $nb_visitors;
    #flock(COUNTER,8);
    close(COUNTER);
    
    return $nb_visitors;
}


################################################################
### store info into a log file in a conveninent way for 
### subsequent login statistics
### Usage:
###     &UpdateLogFile;
sub UpdateLogFile {
  if (open LOG, ">>$log_file") {
    #flock(LOG,2);
    $date = &AlphaDate;
    #$date = `date '+%y%m%d.%H%M%S'`;
    $date =~ s/\n//;
    print LOG join ("\t", 
		    $date,
		    $config_site, 
		    "$ENV{'REMOTE_USER'}\@$ENV{'REMOTE_ADDR'} ($ENV{'REMOTE_HOST'})",
		    $script_name,
		    $query->param('user_email')
		    ), "\n";
    #flock(LOG,8);
    close LOG;
  }
  chmod 0777, $log_file;
}



################################################################
#### send a unix command to remove a file the next day
#### Usage:
#### &DelayedRemoval($file_to_remove, $delay);
####
sub DelayedRemoval {
    my ($file_to_remove, $delay) = @_;
    $delay = "12 hours" unless ($delay);

    unless (-e $file_to_remove) {
	&MessageToAdmin("DelayedRemoval: file $file_to_remove does not exist");
	return();
    }
    unless (-r $file_to_remove) {
	&MessageToAdmin("DelayedRemoval: file $file_to_remove is not readable");
	return();
    }
    unless (-w $file_to_remove) {
	&MessageToAdmin("DelayedRemoval: file $file_to_remove is not writable");
	return();
    }

    &MessageToAdmin("DelayedRemoval: file $file_to_remove will be removed in $delay") if ($ECHO >= 2);

    #### TEMPORARILY INACTIVATED BECAUSE IT MOBILIZES A LOT OF MEMORY
    return();

    open REMOVE, "| at now + $delay";
    print REMOVE "rm -f $file_to_remove \n";
    close REMOVE;
}


################################################################
### prints a list of elements, one per line
sub PrintList {
    my $spacer = "\n";
    foreach $element (@_) {
	print $element;
	print $spacer;
    }

}

################################################################
#### print the command-line arguments
sub PrintArguments {
    my $local_out = $_[0];
#    unless ($local_out)  {
#	$local_out = STDOUT;
#    }
    my $argument_string = "";

    foreach my $a (@main::ARGV) {
	if (($a =~ /\s+/)  ||
	    ($a !~ /\S+/) ||
	    ($a =~ /[\(\)\>\<\&]/)) {
	    $argument_string .= " '$a'";
	} else {
	    $argument_string .= " $a";
	}
    }
    print $local_out $argument_string, "\n" if ($local_out);
    return $argument_string;
}


############################################################
###############  Genome data ###############################
############################################################

@supported_feature_types = qw (CDS mRNA tRNA rRNA scRNA);
%supported_feature_types = ();
foreach my $type (@supported_feature_types) {
    $supported_feature_types{lc($type)} = 1;
}
$supported_feature_types = join ",", @supported_feature_types;


################################################################
## Check if the specified organism name is supported on this server
sub CheckOrganismName {
    my ($organism_name) = @_;
     unless ($supported_organism{$organism_name}) {
	&RSAT::error::FatalError("Organism $organism_name is not supported.",
		    "Supported on this site : \n".&ListSupportedOrganisms());
    }
}

################################################################
#### Check if an organism is supported on the current installation,
#### and open streams to read its genome sequence.
####
#### Usage
#### -----
#### Automatic selection of genome and feature file : 
####    &CheckOrganism($organism_name); 
####
#### Manual specification of input files :
#### &CheckOrganism($organism_name, 
####                $annotation_table, 
####                $input_sequence_format);
sub CheckOrganism {
    my ($organism_name, $annotation_table, $input_sequence_file, $input_sequence_format) = @_;
    my $organism_object = new RSAT::organism();
    $organism_object->OpenContigs($organism_name, 
				  $annotation_table, 
				  $input_sequence_file, 
				  $input_sequence_format);
    return $organism_object;
}




################################################################
## Return a list of the supported organisms
## various formats are supported
sub ListSupportedOrganisms {
  my $out_format = $_[0] || "text";

  foreach my $key (keys %main::supported_organism) {
      $names{$key} = $main::supported_organism{$key}->{'name'};
#      print "HELLO $key\t",$main::supported_organism{$key}->{'name'}, "\t", $names{$key}, "\n";;
  }
  @sorted_names = sort values %names;
  @sorted_keys = sort keys %supported_organism;

  if ($out_format eq "html_list") {
      my $result = "<UL>\n";
      foreach my $name (@sorted_names) {
	  $result .= "<LI>";
	  $result .= $name;
	  $result .= "\n";
      }
      $result .= "</UL>\n";
      return $result;
  } elsif ($out_format eq "html_table") {
      my $result = "<TABLE>\n";
      foreach my $key (@sorted_keys) {
	  $result .= "<TR>\n";
	  $result .= "<TD>$key</TD>\n";
	  $result .= "<TD>";
	  $result .= $names{$key};
	  $result .= "</TD>\n";
	  $result .= "</TR>\n";
      }
      $result .= "</TABLE>\n";
      return $result;
  } elsif (($out_format eq "names") ||
	   ($out_format eq "array")) {
      return @sorted_names;
  } elsif ($out_format eq "keys") {
      return @sorted_keys;
  } elsif ($out_format eq "hash") {
      my %result = ();
      foreach my $ket (@sorted_keys) {
	  $result{$key} = $main::supported_organism{$key}->{name};
      }
      return %result;
  } elsif ($out_format eq "sizes") {
      #### collect the default limits for each organism
      my $result = sprintf ";\t%-35s\t%7s\t%7s\t%s\n", "Organism", "upstream from", "upstream to", "taxonomy";
      foreach my $key (sort @sorted_keys) {
	  $result .= sprintf ("\t%-35s\t%7s\t%7s\t%s\n", 
			      $key, 
			      $supported_organism{$key}->{'up_from'},
			      $supported_organism{$key}->{'up_to'}
			      );
      }
      return $result;
  } elsif ($out_format eq "full") {
      #### collect the default limits for each organism
      my $result = join ("\t", 
			 "; organism",
			 "taxid", 
			 "taxonomy", 
			 "last update", 
			 "upstream from", 
			 "upstream to")."\n";
      foreach my $key (sort @sorted_keys) {
	  $result .= join ("\t", 
			   $key,  
			   $supported_organism{$key}->{'taxid'},
			   $supported_organism{$key}->{'taxonomy'},
			   $supported_organism{$key}->{'last_update'},
			   $supported_organism{$key}->{'up_from'},
			   $supported_organism{$key}->{'up_to'}
			   )."\n";
      }
      return $result;
  } else {
      my $result = "";
      foreach $key (@sorted_keys) {
	  $result .= sprintf "\t\t%-30s", $key;
	  $result .= "\t";
	  $result .= $names{$key};
	  $result .= "\n";
      }
      return $result;
  }
}

$supported_organisms = &ListSupportedOrganisms();





# ################################################################
# ## Methods below have been transferred to RSAT::util

sub ConvertStrand {
    return &RSAT::util::ConvertStrand(@_);
}

sub OpenInputFile {
    return &RSAT::util::OpenInputFile(@_);
}

sub OpenOutputFile {
    return &RSAT::util::OpenOutputFile(@_);
}

sub IsNatural {
    return &RSAT::util::IsNatural(@_);
}

sub IsInteger {
    return &RSAT::util::IsInteger(@_);
}

sub IsReal {
    return &RSAT::util::IsReal(@_);
}

sub round {
    return &RSAT::util::round(@_);
}

sub trim {
    return &RSAT::util::trim(@_);
}

sub AlphaDate {
    return &RSAT::util::AlphaDate(@_);
}

sub SplitFileName {
    return &RSAT::util::SplitFileName(@_);
}

sub ShortFileName {
    return &RSAT::util::ShortFileName(@_);
}

sub ExtractPath {
    return &RSAT::util::ExtractPath(@_);
}

################################################################
#### Treatment of warnings and  errors
################################################################


################################################################
### Messages and errors are now passed to RSAT::message and RSAT::error
sub FatalError {
    &RSAT::error::FatalError(@_);
}

sub cgiError {
    &RSAT::error::cgiError(@_);
}


sub Warning {
    &RSAT::message::Warning(@_);
}

sub cgiWarning {
    &RSAT::message::cgiWarning(@_);
}

sub Info {
    &RSAT::message::Info(@_);
}

sub cgiMessage {
    &RSAT::message::cgiMessage(@_);
}

sub TimeWarn {
    &RSAT::message::timeWarn(@_);
}

sub MessageToAdmin {
    &RSAT::message::MessageToAdmin(@_);
}


################################################################
## Changed the name of this method
sub ReadFamilies {
    &ReadClasses(@_);
}

################################################################
#### read classification file
#### The file is supposed to contain at least two columns 
#### - element (e.g. a gene ID)
#### - class (e.g. a functional class, or a regulon, or a clustering result)
#### additional columns are allowed, but they are ignored
sub ReadClasses {
    my ($family_file, $get_orf_id, $organism, $no_subst) = @_;
    warn "; Reading family file\t$family_file\n" 
	if ($main::verbose >=2);

    my %family = ();
    my ($fam) = &OpenInputFile($family_file);

    my $line = 0;
    while (<$fam>) {
	$line++;
	next if (/^;/);
	next if (/^\#/);
	next unless (/\S/);
	chomp;
	s/\r$//;
	my @fields = split /\t/;
	
	### family member
	$member_name = &trim(uc($fields[0]));
	unless ($member_name =~ /\S/) {
	    &RSAT::message::Warning(join ("\t", "Error family file", 
					  $family_file,  "line", 
					  $line, "member not specified")) if ($main::verbose >= 1);
	    next;
	}

	### family name
	$family_name = &trim($fields[1]);
	unless ($no_subst) {
	    $subst_char = ".";
	    $family_name =~ s/ +/${subst_char}/g; ## spaces create problems with file names in Unix
	    $family_name =~ s/\//${subst_char}/g; ## spaces create problems with file names in Unix
	    $family_name =~ s/\:/${subst_char}/g; ## spaces create problems with file names in Unix
	    $family_name =~ s/\(/${subst_char}/g; ## paretheses interfere with Unix commands
	    $family_name =~ s/\)/${subst_char}/g; ## paretheses interfere with Unix commands
	}
	unless ($family_name =~ /\S/) {
	    &RSAT::message::Warning(join("\t", "Error family file", 
				    $family_file,  "line", 
				    $line, "family not specified")) if ($main::verbose >= 1);
	    next;
	}

	#### create a new family if required
	unless ($family{$family_name}) {
	    $family{$family_name} = new RSAT::Family(name=>$family_name);
	}

	################################################################
	### identify the gene on the basis of its name
	my $member_key = "";
	if (($get_orf_id) && ($organism)) {
	    ### identify the gene on the basis of its name
	    my $feature = $organism->get_feature_for_name($member_name);
	    if ($feature) {
		$member_key = $feature->get_attribute("id");
	    } else {
		&RSAT::message::Warning(join ("\t", "organism", $organism->get_attribute("name"), 
					      "has no feature with name", $member_name));
	    }
#	    $member_key = $orf_id{$member_name};
	} else {
	    $member_key = $member_name;
	}
	if ($member_key) {
	    $family{$family_name}->new_member($member_key);
	    &RSAT::message::Warning( join ("\t",  ";", $family_name,
					   $member_name,
					   $member_key,
					   $name{$id}) ) if ($main::verbose >= 5);
	} else {
	    &RSAT::message::Warning ($member_name." unknown gene name");
	}
	
    }
    close $fam if ($family_file);
    return %family;
}

################################################################
#### when grouping occurrences with their reverse complement, 
#### only retain one of each pair. 
sub GroupRC {
    &RSAT::message::TimeWarn("Grouping pairs of reverse complements\n") if ($main::verbose >= 2);
    foreach $pattern_seq (keys %patterns) {
	$rc_pattern_seq = &SmartRC($pattern_seq);
	warn ("; Grouping reverse complements\t", $pattern_seq, "\t", $rc_pattern_seq, "\n") if ($main::verbose >= 4);
	if ($rc_pattern_seq gt $pattern_seq) { ### only suppress one oligo from the pair
	    delete $patterns{$rc_pattern_seq};
	}
    }
}


################################################################
## Do the opposite as GroupRC: starting from the grouped RC, re-create
## one pattern for the RC of each pattern
sub UngroupRC {
    &RSAT::message::TimeWarn("; Reporting both elements of reverse complements pairs\n") if ($main::verbose >= 2);
    foreach $pattern_seq (keys %patterns) {
	$rc_pattern_seq = &SmartRC($pattern_seq);
	warn ("; Ungrouping reverse complements\t", $pattern_seq, "\t", $rc_pattern_seq, "\n") if ($main::verbose >= 4);
	if ($rc_pattern_seq gt $pattern_seq) { ### only suppress one oligo from the pair
	    $patterns{$rc_pattern_seq} = $patterns{$pattern_seq} ;
	}
    }
}

#### end of the library #####

1; # return true



